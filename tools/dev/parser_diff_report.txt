=== parser.php vs archive/_orig_parser.php ===
Current includes/parser.php SHA256: 62D24597866B8F492F67F53CF2C737F99045299CD404D8DF34C390FEA5B46C2B
Archive tools/archive/_orig_parser.php SHA256: 9D490112D16DBE60ACD04F6C95EB4FF62C04792CEE7CD159AA03C558F915CF16
=== Diff parser ===
diff --git a/tools/archive/_orig_parser.php b/includes/parser.php
index ab74f21..0b469cc 100644
--- a/tools/archive/_orig_parser.php
+++ b/includes/parser.php
@@ -1,6 +1,18 @@
-´╗┐<?php
+<?php
 if (!defined('ABSPATH')) exit;
 
+// Load parser helpers (PCRE2-safe tokenizer, qty parsing, unit aliases)
+// Keep renderer untouched; helpers are parser-internal only.
+$__sitc_helpers = __DIR__ . '/parser_helpers.php';
+if (is_file($__sitc_helpers)) {
+    require_once $__sitc_helpers;
+}
+// Ingredients adapter (E1)
+$__sitc_ing_adapter = __DIR__ . '/ingredients/parse_line.php';
+if (is_file($__sitc_ing_adapter)) {
+    require_once $__sitc_ing_adapter;
+}
+
 /**
  * Parser: Extrahiert Rezeptdaten aus einer URL (JSON-LD bevorzugt, Fallback HTML).
  */
@@ -180,8 +192,16 @@ function sitc_parse_recipe_from_url_v2(string $url) {
         foreach ($r['ingredientsParsed'] as $p) {
             $name = trim((string)($p['item'] ?? ''));
             if (!empty($p['note'])) $name .= ' ('.trim((string)$p['note']).')';
+            $qval = $p['qty'] ?? '';
+            if (is_array($qval) && isset($qval['low'],$qval['high'])) {
+                $qtyOut = str_replace(',', '.', (string)((float)$qval['low'])) . '-' . str_replace(',', '.', (string)((float)$qval['high']));
+            } elseif ($qval === null || $qval === '') {
+                $qtyOut = '';
+            } else {
+                $qtyOut = is_numeric($qval) ? str_replace(',', '.', (string)$qval) : (string)$qval;
+            }
             $ingredients_struct[] = [
-                'qty'  => $p['qty'] ?? '',
+                'qty'  => $qtyOut,
                 'unit' => $p['unit'] ?? '',
                 'name' => $name !== '' ? $name : ($p['raw'] ?? '')
             ];
@@ -495,6 +515,16 @@ function sitc_extract_dom_fallback(DOMDocument $doc, array $scopeSelectors, arra
                 }
             }
         }
+        // HOTFIX A: If we detected container nodes, prefer itemized <li> entries under root
+        $listContainers = (new DOMXPath($doc))->query('.//ul|.//ol', $root);
+        if ($listContainers && $listContainers->length > 0) {
+            $tmp = [];
+            foreach ((new DOMXPath($doc))->query('.//li', $root) as $li) {
+                $t = trim(preg_replace('/\s+/', ' ', $li->textContent ?? ''));
+                if ($t && !preg_match('/(zutaten|ingredients)/i', $t)) $tmp[] = $t;
+            }
+            if ($tmp) { $ings = $tmp; $groups = []; $currentGroup = null; }
+        }
     } else {
         // Generic list items inside root
         foreach ((new DOMXPath($doc))->query('.//li', $root) as $li) {
@@ -608,34 +638,50 @@ function sitc_normalize_recipe(array $recipe, DOMDocument $doc, ?string $pageUrl
     $yieldParsed = sitc_parse_yield_normalized($rawYield);
     $recipe['yieldNormalized'] = $yieldParsed + ['raw'=>$rawYield];
 
-    // Ingredients + groups + parsed
-    $ingList = [];
+    // Ingredients -> structured [{ raw, qty, unit, item, note? }]
+    $ingInput = [];
     if (isset($recipe['recipeIngredient'])) {
-        $ingList = $recipe['recipeIngredient'];
-        if (!is_array($ingList)) $ingList = [$ingList];
-        $ind = array_values(array_filter(array_map(function($s){ return sitc_clean_text((string)$s); }, $ingList), function($s){ return $s !== ''; }));
-        // De-Dupe (case-/diacritics-/whitespace-insensitiv)
-        $seen = [];
-        $dedup = [];
-        foreach ($ind as $line) {
-            $key = sitc_canon_key($line);
-            if ($key === '') continue;
-            if (!isset($seen[$key])) { $seen[$key] = true; $dedup[] = $line; }
-        }
-        $ingList = $dedup;
+        $ingInput = $recipe['recipeIngredient'];
+        if (!is_array($ingInput)) $ingInput = [$ingInput];
     }
-    $recipe['recipeIngredient'] = $ingList;
-
-    // Create ingredientsParsed
-    $parsed = [];
-    foreach ($ingList as $raw) {
-        if (function_exists('sitc_parse_ingredient_line_v3')) {
-            $parsed[] = sitc_parse_ingredient_line_v3($raw);
+    $struct = [];
+    foreach ($ingInput as $entry) {
+        // Normalize to raw line
+        if (is_array($entry) && (isset($entry['raw']) || isset($entry['item']))) {
+            $rawLine = isset($entry['raw']) ? (string)$entry['raw'] : trim((string)($entry['item'] ?? ''));
+        } elseif (is_array($entry) && (array_key_exists('qty',$entry) || array_key_exists('unit',$entry) || array_key_exists('name',$entry))) {
+            $q = trim((string)($entry['qty'] ?? ''));
+            $u = trim((string)($entry['unit'] ?? ''));
+            $n = trim((string)($entry['name'] ?? ''));
+            $rawLine = trim(($q!==''?$q.' ':'').($u!==''?$u.' ':'').$n);
+        } else {
+            $rawLine = sitc_clean_text((string)$entry);
+        }
+        if ($rawLine === '') continue;
+        if (function_exists('sitc_parse_ingredient_line')) {
+            $one = sitc_parse_ingredient_line($rawLine, 'de');
+            if (is_array($one)) $struct[] = $one;
         } else {
-            $parsed[] = sitc_parse_ingredient_line_v2($raw);
+            foreach ((function_exists('sitc_struct_from_line_df2') ? sitc_struct_from_line_df2($rawLine) : sitc_struct_from_line_e1($rawLine)) as $s) $struct[] = $s;
         }
     }
-    $recipe['ingredientsParsed'] = $parsed;
+    // De-Dupe on display-like key: qty (single or low-high) + unit + item (canon)
+    $seen = [];
+    $dedup = [];
+    foreach ($struct as $s) {
+        $q = $s['qty'];
+        if (is_array($q) && isset($q['low'],$q['high'])) { $qk = sprintf('%.3f-%.3f', (float)$q['low'], (float)$q['high']); }
+        elseif ($q !== null) { $qk = sprintf('%.3f', (float)$q); } else { $qk = ''; }
+        $uk = mb_strtolower(trim((string)($s['unit'] ?? '')), 'UTF-8');
+        $nk = sitc_canon_key((string)($s['item'] ?? ''));
+        $key = $qk.'|'.$uk.'|'.$nk;
+        if ($key === '||') continue;
+        if (!isset($seen[$key])) { $seen[$key] = true; $dedup[] = $s; }
+    }
+    $struct = $dedup;
+
+    $recipe['recipeIngredient'] = $struct;
+    $recipe['ingredientsParsed'] = $struct;
 
     // Instructions -> flatten
     if (isset($recipe['recipeInstructions'])) {
@@ -817,6 +863,8 @@ function sitc_flatten_instructions($instr): array {
         }
     } elseif (is_string($instr)) {
         $parts = preg_split('/\r?\n|\.\s+(?=[A-ZÔö£├ñÔö£├╗Ôö£┬ú])/u', $instr);
+        if ($parts === false) { trigger_error('Regex failed @sitc_flatten_instructions preg_split', E_USER_WARNING); $parts = [$instr]; }
+        if ($parts === false) { trigger_error('Regex failed @sitc_flatten_instructions preg_split', E_USER_WARNING); $parts = [$instr]; }
         foreach ($parts as $p) { $t = sitc_clean_text($p); if ($t!=='') $out[] = ['@type'=>'HowToStep','text'=>$t]; }
     }
     return $out;
@@ -847,11 +895,193 @@ function sitc_query_selector(DOMXPath $xp, string $selector, ?DOMNode $context=n
     return $xp->query($xpath, $context);
 }
 
-function sitc_clean_text($val): string {
+// Global text sanitization for all incoming strings
+// - HTML entities decode
+// - Strip tags, collapse whitespace
+// - Normalize to UTF-8 NFC
+// - Common UTF-8 mojibake fixes
+function sitc_text_sanitize($val): string {
     $s = is_string($val) ? $val : json_encode($val);
-    $s = html_entity_decode(strip_tags($s), ENT_QUOTES | ENT_HTML5, 'UTF-8');
-    $s = trim(preg_replace('/\s+/u', ' ', $s));
-    return sitc_nfc($s);
+    // 1) Decode entities first
+    $s = html_entity_decode($s, ENT_QUOTES | ENT_HTML5, 'UTF-8');
+    // 2) NFC normalize early to stabilize sequences
+    $s = sitc_nfc($s);
+    // 3) Mojibake fixes (common pairs)
+    $map = [
+        'St├â┬╝ck' => 'St├╝ck', '├â┬╝' => '├╝', '├â┬Â' => '├Â', '├â┬ñ' => '├ñ', '├â┼©' => '├ƒ',
+        '├âÔÇ×' => '├ä', '├âÔÇô' => '├û', '├â┼ô' => '├£',
+        '├óÔé¼ÔÇ£' => 'ÔÇô', '├óÔé¼ÔÇØ' => 'ÔÇö', '├óÔé¼┼¥' => 'ÔÇ×', '├óÔé¼┼ô' => 'ÔÇ£', '├óÔé¼╦£' => 'ÔÇÜ', '├óÔé¼Ôäó' => 'ÔÇÖ', '├óÔé¼┬ª' => 'ÔÇª'
+    ];
+    $s = strtr($s, $map);
+    // 4) Strip tags and collapse whitespace
+    $s = strip_tags($s);
+    $s = preg_replace('/\s+/u', ' ', $s);
+    $s = trim($s);
+    // 5) Final NFC
+    $s = sitc_nfc($s);
+    return $s;
+}
+
+// ===== Quantities + struct helpers (parser-scoped) =====
+
+function sitc_unicode_fraction_decimal_map(): array {
+    return [
+        '┬╝' => 0.25,
+        '┬¢' => 0.5,
+        '┬¥' => 0.75,
+        'Ôàô' => 1/3,
+        'Ôàö' => 2/3,
+        'Ôàø' => 0.125,
+    ];
+}
+
+if (!function_exists('sitc_qty_pre_normalize_parser')) {
+function sitc_qty_pre_normalize_parser(string $s): string {
+    $t = trim($s);
+    if ($t === '') return '';
+    // NBSP / NNBSP to space
+    $t = preg_replace('/[\x{00A0}\x{202F}]/u', ' ', $t);
+    // drop leading stopwords and (ca.) suffix
+    $t = preg_replace('/^(ca\.?|circa|etwa|ungef\.?|ungef(?:ae|├ñ)hr\.?|about|approx\.?|approximately)\s+/iu', '', $t);
+    $t = preg_replace('/\((?:ca\.?|circa|about|approx\.?)\)\s*$/iu', '', $t);
+    // unify range separators
+    $t = preg_replace('/[\x{2012}-\x{2015}]/u', '-', $t);
+    // tighten slash
+    $t = preg_replace('/\s*\/\s*/u', '/', $t);
+    // unicode fractions to decimals or mixed numbers
+    $map = sitc_unicode_fraction_decimal_map();
+    // mixed number: 1┬¢ -> 1 + 0.5
+    $t = preg_replace_callback('/(\d)\s*(['.preg_quote(implode('', array_keys($map)), '/').'])/u', function($m) use ($map){
+        $dec = $map[$m[2]] ?? null; if ($dec === null) return $m[0];
+        $sum = (float)$m[1] + (float)$dec;
+        return str_replace('.', ',', (string)$sum); // favor comma within text
+    }, $t);
+    // standalone unicode fraction -> decimal string
+    $t = preg_replace_callback('/(['.preg_quote(implode('', array_keys($map)), '/').'])/u', function($m) use ($map){
+        $dec = $map[$m[1]] ?? null; return $dec !== null ? str_replace('.', ',', (string)$dec) : $m[1];
+    }, $t);
+    return $t;
+}
+}
+
+function sitc_qty_to_float(string $num): ?float {
+    $n = trim($num);
+    if ($n === '') return null;
+    // mixed number: 1 1/2
+    if (preg_match('/^(\d+)\s+(\d+)\/(\d+)$/', $n, $m)) return (float)$m[1] + ((float)$m[2]/max(1,(float)$m[3]));
+    // fraction a/b
+    if (preg_match('/^(\d+)\/(\d+)$/', $n, $m)) return ((float)$m[1])/max(1,(float)$m[2]);
+    // decimal with comma or dot
+    if (preg_match('/^\d+(?:[\.,]\d+)?$/', $n)) return (float)str_replace(',', '.', $n);
+    return null;
+}
+
+if (!function_exists('sitc_parse_qty_or_range_parser')) {
+function sitc_parse_qty_or_range_parser(string $s) {
+    $t = sitc_qty_pre_normalize_parser($s);
+    // range aÔÇôb (minus or unicode dashes)
+    if (preg_match('/^(\S+)\h*[\-\x{2012}-\x{2015}]\h*(\S+)$/u', $t, $m)) {
+        $a = sitc_qty_from_token($m[1]);
+        $b = sitc_qty_from_token($m[2]);
+        if ($a !== null && $b !== null) return ['low'=>(float)$a,'high'=>(float)$b];
+    }
+    $v = sitc_qty_from_token($t);
+    if ($v !== null) return (float)$v;
+    return null;
+}
+}
+
+if (!function_exists('sitc_unit_alias_canonical')) {
+function sitc_unit_alias_canonical(string $u): ?string {
+    $m = [
+        'g'=>'g','gram'=>'g','grams'=>'g','gramm'=>'g',
+        'kg'=>'kg',
+        'ml'=>'ml','milliliter'=>'ml','millilitre'=>'ml',
+        'l'=>'l','liter'=>'l','litre'=>'l',
+        'tl'=>'tsp','teeloeffel'=>'tsp','teel├Âffel'=>'tsp','tsp'=>'tsp','teaspoon'=>'tsp','teaspoons'=>'tsp',
+        'el'=>'tbsp','essloeffel'=>'tbsp','essl├Âffel'=>'tbsp','tbsp'=>'tbsp','tablespoon'=>'tbsp','tablespoons'=>'tbsp',
+        'tasse'=>'cup','cup'=>'cup','cups'=>'cup',
+        'prise'=>'pinch','pinch'=>'pinch',
+        'stueck'=>'piece','st├╝ck'=>'piece','piece'=>'piece','pieces'=>'piece',
+        'bund'=>'bunch','bunch'=>'bunch',
+        'zehe'=>'clove','zehen'=>'clove','clove'=>'clove','cloves'=>'clove'
+    ];
+    $k = mb_strtolower(trim($u), 'UTF-8');
+    if ($k === 'stk' || $k === 'st├╝ck') return 'piece';
+    return $m[$k] ?? null;
+}
+}
+
+if (!function_exists('sitc_struct_from_line')) {
+function sitc_struct_from_line(string $rawLine): array {
+    $out = [];
+    $pn = sitc_qty_pre_normalize_parser($rawLine);
+    // split into parts by multiple qty tokens or common separators
+    $parts = preg_split('/\s*[ÔÇó;\u00B7]\s*|\s{2,}/u', $pn);
+    if ($parts === false) { trigger_error('Regex failed @sitc_struct_from_line preg_split', E_USER_WARNING); $parts = [$pn]; }
+    $parts = array_values(array_filter(array_map('trim',$parts), fn($s)=>$s!==''));
+    if (!$parts) $parts = [$pn];
+    foreach ($parts as $part) {
+        // If more than one qty token in part, split before subsequent ones
+        if (preg_match_all('/(?:(?:\d+(?:[\.,]\d+)?)|\d+\/\d+)/u', $part, $mm, PREG_OFFSET_CAPTURE) && count($mm[0])>1) {
+            $segments = [];
+            $last = 0;
+            foreach ($mm[0] as $i=>$m) {
+                if ($i===0) continue;
+                $off = $m[1];
+                $segments[] = trim(substr($part, $last, $off-$last));
+                $last = $off;
+            }
+            $segments[] = trim(substr($part, $last));
+        } else {
+            $segments = [$part];
+        }
+        foreach ($segments as $seg) {
+            if ($seg==='') continue;
+            $qtyField = null; $unitField = null; $itemField = ''; $noteField = null;
+            // qty + optional unit at start
+            if (preg_match('/^\s*([^\s,()]+)\s*(\p{L}+)?\s*(.*)$/u', $seg, $m)) {
+                $qtyParsed = sitc_parse_qty_or_range_parser($m[1]);
+                if (is_array($qtyParsed) || is_float($qtyParsed)) { $qtyField = $qtyParsed; }
+                $u = trim((string)($m[2] ?? ''));
+                if ($u !== '') { $unitField = sitc_unit_alias_canonical($u); }
+                $rest = trim((string)($m[3] ?? ''));
+                // Leading TK as note
+                if (preg_match('/^TK\b/u', $rest)) { $noteField = 'TK'; $rest = trim(preg_replace('/^TK\b\s*/u','',$rest)); }
+                // Parentheses note
+                if (preg_match('/^(.*)\(([^\)]+)\)\s*$/u', $rest, $n)) { $itemField = trim($n[1]); $noteField = trim(($noteField? $noteField.'; ':'').$n[2]); }
+                else $itemField = $rest;
+                // Trailing comma note
+                if (strpos($itemField, ',') !== false) {
+                    $parts2 = array_map('trim', explode(',', $itemField, 2));
+                    if (count($parts2)===2) { $itemField = $parts2[0]; $noteField = trim(($noteField? $noteField.'; ':'').$parts2[1]); }
+                }
+                // Hyphen item-note like "Ingwer-St├╝ck"
+                if ($noteField===null && preg_match('/^(.+?)\s*[-ÔÇô]\s*(St(ue|├╝)ck|gehackt|rot)\b/u', $itemField, $h)) {
+                    $itemField = trim($h[1]); $noteField = $h[3]=='St├╝ck' || $h[3]=='Stueck' ? 'St├╝ck' : $h[3];
+                }
+                // Heuristic: Knoblauchzehen -> unit clove + item Knoblauch
+                if ($unitField===null && preg_match('/^knoblauchzehen?\b/iu', $itemField)) { $unitField='clove'; $itemField='Knoblauch'; }
+                if ($unitField===null && preg_match('/^(zehe|zehen)\b/iu', $itemField)) { $unitField='clove'; $itemField=preg_replace('/^(zehe|zehen)\b\s*/iu','',$itemField); }
+            } else {
+                $itemField = $seg;
+            }
+            $out[] = [
+                'raw'  => $seg,
+                'qty'  => $qtyField,
+                'unit' => $unitField,
+                'item' => trim($itemField),
+                'note' => $noteField !== null ? $noteField : null,
+            ];
+        }
+    }
+    return $out;
+}
+}
+
+// Backward-compat: existing code calls sitc_clean_text; delegate to sanitize
+function sitc_clean_text($val): string {
+    return sitc_text_sanitize($val);
 }
 
 // Build a canonical key for de-duplication: trim, collapse whitespace, lower-case, remove diacritics
@@ -898,9 +1128,50 @@ function sitc_to_float(string $num): float {
     return (float)str_replace(',', '.', $num);
 }
 
+// PCRE2-safe split helper: never returns false
+if (!function_exists('sitc_pcre2_split')) {
+function sitc_pcre2_split(string $pattern, string $s): array {
+    $out = @preg_split($pattern, $s, -1, PREG_SPLIT_NO_EMPTY);
+    return is_array($out) ? $out : [$s];
+}
+}
+
+// Parse quantity token to float, handling unicode fractions, mixed numbers, and decimal comma
+if (!function_exists('sitc_qty_from_token')) {
+function sitc_qty_from_token(string $t): ?float {
+    $s = trim($t);
+    if ($s === '') return null;
+    // normalize decimal comma and slash spacing
+    $s = str_replace(',', '.', $s);
+    $s = preg_replace('/\s*\/\s*/u', '/', $s);
+    if ($s === null) $s = $t;
+    // map unicode fractions
+    $map = [
+        "┬¢"=>0.5, "┬╝"=>0.25, "┬¥"=>0.75, "Ôàô"=>0.3333, "Ôàö"=>0.6667, "Ôàø"=>0.125,
+    ];
+    // mixed number like 1┬¢
+    if (preg_match('/^([0-9]+)\s*([┬¢┬╝┬¥ÔàôÔàöÔàø])$/u', $s, $m)) {
+        $base = (float)$m[1]; $frac = $map[$m[2]] ?? 0.0; return $base + (float)$frac;
+    }
+    // mixed number like 1 1/2
+    if (preg_match('/^([0-9]+)\s+([0-9]+)\/([0-9]+)$/u', $s, $m)) {
+        $a=(float)$m[1]; $b=(float)$m[2]; $c=max(1.0,(float)$m[3]); return $a + ($b/$c);
+    }
+    // simple unicode fraction
+    if (preg_match('/^([┬¢┬╝┬¥ÔàôÔàöÔàø])$/u', $s, $m)) { return (float)($map[$m[1]] ?? 0.0); }
+    // simple a/b
+    if (preg_match('/^([0-9]+)\/([0-9]+)$/u', $s, $m)) { return (float)$m[1] / max(1.0,(float)$m[2]); }
+    // plain decimal
+    if (preg_match('/^[0-9]+(?:\.[0-9]+)?$/u', $s)) { return (float)$s; }
+    return null;
+}
+}
+
 // Ingredient line parser v2 -> { qty:?float, unit:?string, item:string, note:?string, raw:string }
 function sitc_parse_ingredient_line_v2(string $raw): array {
     $raw = sitc_clean_text($raw);
+    // Additional normalization for unicode fractions and spaces
+    if (function_exists('sitc_qty_pre_normalize')) { $raw = sitc_qty_pre_normalize($raw); }
     // map unicode fractions
     $raw = strtr($raw, ['Ôö¼┬ó'=>' 1/2','Ôö¼ÔòØ'=>' 1/4','Ôö¼┬Ñ'=>' 3/4','├ö├á├┤'=>' 1/3','├ö├á├Â'=>' 2/3']);
     // Units mapping de<->en
@@ -993,6 +1264,7 @@ function sitc_parse_instructions($input) {
         }
     } elseif (is_string($input)) {
         $parts = preg_split('/\r?\n|\.\s+(?=[A-ZÔö£├ñÔö£├╗Ôö£┬ú])/u', $input);
+        if ($parts === false) { trigger_error('Regex failed @sitc_parse_instructions preg_split', E_USER_WARNING); $parts = [$input]; }
         foreach ($parts as $p) {
             $p = trim($p);
             if ($p) $steps[] = $p;
@@ -1040,7 +1312,10 @@ function sitc_parse_ingredient_line_v3(string $raw): array {
         $a = $toFloat($m[1]); $b=$toFloat($m[2]);
         if ($a !== null && $b !== null) {
             $qty = str_replace(',', '.', (string)$a) . '-' . str_replace(',', '.', (string)$b);
-            $u = mb_strtolower(trim($m[3] ?? ''), 'UTF-8'); if ($u !== '') $unit = $aliases[$u] ?? $u;
+            $u = mb_strtolower(trim($m[3] ?? ''), 'UTF-8');
+            if ($u !== '') {
+                $unit = $aliases[$u] ?? $u;
+            }
             $rest = trim($m[4] ?? '');
             if (preg_match('/^(.*)\(([^\)]+)\)\s*$/', $rest, $n)) { $item = trim($n[1]); $note = trim($n[2]); }
             else $item = $rest;
@@ -1053,7 +1328,10 @@ function sitc_parse_ingredient_line_v3(string $raw): array {
         $qv = $toFloat(trim($m[1]));
         if ($qv !== null) {
             $qty = str_replace(',', '.', (string)$qv);
-            $u = mb_strtolower(trim($m[2] ?? ''), 'UTF-8'); if ($u !== '') $unit = $aliases[$u] ?? $u;
+            $u = mb_strtolower(trim($m[2] ?? ''), 'UTF-8');
+            if ($u !== '') {
+                $unit = $aliases[$u] ?? $u;
+            }
             $rest = trim($m[3] ?? '');
             if (preg_match('/^(.*)\(([^\)]+)\)\s*$/', $rest, $n)) { $item = trim($n[1]); $note = trim($n[2]); }
             else $item = $rest;
@@ -1073,3 +1351,5 @@ function sitc_parse_ingredient_line_v3(string $raw): array {
     return ['qty'=>null,'unit'=>null,'item'=>$orig,'note'=>null,'raw'=>$orig,'ambiguous'=>true];
 }
 }
+
+
=== parser_helpers.php vs archive/tmp_helpers_copy.txt ===
Current includes/parser_helpers.php SHA256: FDABD316D94E38EB8C07CFF8AE60A8B0B46F05F2603504D9B606E6096908771B
Archive tools/archive/tmp_helpers_copy.txt SHA256: 11138CF06B20FC9DCF756AF77264F7CB17FF43D5E38F1C36424DF965A03C44DE
=== Diff parser_helpers ===
diff --git a/tools/archive/tmp_helpers_copy.txt b/includes/parser_helpers.php
index 14493f5..35fe1a8 100644
--- a/tools/archive/tmp_helpers_copy.txt
+++ b/includes/parser_helpers.php
@@ -1,121 +1,817 @@
 ´╗┐<?php
-declare(strict_types=1);
-
 if (!defined('ABSPATH')) exit;
-function sitc_normalize_array_meta($value) {
-    if (is_array($value)) return $value;
-    if (is_string($value) && $value !== '') {
-        $json = json_decode($value, true);
-        if (json_last_error() === JSON_ERROR_NONE && is_array($json)) return $json;
-        $maybe = maybe_unserialize($value);
-        if (is_array($maybe)) return $maybe;
+
+// PCRE2-safe split helper: never returns false; returns [$s] on regex failure
+if (!function_exists('sitc_pcre2_split')) {
+    function sitc_pcre2_split(string $pattern, string $s): array {
+        $out = @preg_split($pattern, $s, -1, PREG_SPLIT_NO_EMPTY);
+        return is_array($out) ? $out : [$s];
+    }
+}
+
+// E4 helpers: minimal normalizers (guards)
+if (!function_exists('sitc_norm_strip_stopwords')) {
+    function sitc_norm_strip_stopwords(string $s): string {
+        // Delegate to existing stopword stripper if present
+        if (function_exists('sitc_strip_stopwords_qty_context')) {
+            return sitc_strip_stopwords_qty_context($s);
+        }
+        // Basic leading patterns
+        return preg_replace('/^\s*(?:ca\.?|circa|etwa|ungef\.?|ungef(?:ae|├ñ)hr\.?|about|approx\.?|approximately|\(ca\.?\))\s+/iu', ' ', $s) ?? $s;
+    }
+}
+
+if (!function_exists('sitc_norm_unify_dashes')) {
+    function sitc_norm_unify_dashes(string $s): string {
+        return preg_replace('/[\x{2012}-\x{2015}]/u', '-', $s) ?? $s;
+    }
+}
+
+if (!function_exists('sitc_norm_fractions_to_decimal')) {
+    function sitc_norm_fractions_to_decimal(string $s): string {
+        // Insert plus for mixed forms with unicode vulgar fractions
+        $s = preg_replace('/(\d)\s*([\x{00BD}\x{00BC}\x{00BE}\x{2153}\x{2154}\x{215B}])/u', '$1+$2', $s) ?? $s;
+        // Map unicode to ASCII fraction tokens
+        $map = [
+            "\x{00BD}"=>'1/2', "\x{00BC}"=>'1/4', "\x{00BE}"=>'3/4',
+            "\x{2153}"=>'1/3', "\x{2154}"=>'2/3', "\x{215B}"=>'1/8',
+        ];
+        $s = strtr($s, $map);
+        // Mixed ASCII form: "a b/c" -> "a+b/c"
+        $s = preg_replace('/(?<!\d)(\d+)\s+(\d+)\/(\d+)(?!\d)/u', '$1+$2/$3', $s) ?? $s;
+        return $s;
+    }
+}
+
+if (!function_exists('sitc_norm_commas_to_dot')) {
+    function sitc_norm_commas_to_dot(string $s): string {
+        return preg_replace('/(\d),(?=\d)/u', '.', $s) ?? $s;
+    }
+}
+
+if (!function_exists('sitc_norm_trim_ws')) {
+    function sitc_norm_trim_ws(string $s): string {
+        $t = preg_replace('/\s+/u', ' ', $s);
+        return trim($t ?? $s);
+    }
+}
+
+// FIX-QTY-CORE: normalize unicode fractions (incl. mixed forms like 1┬¢ -> 1 1/2)
+if (!function_exists('sitc_normalize_unicode_fractions')) {
+    function sitc_normalize_unicode_fractions(string $s): string {
+        // Insert space between integer and unicode fraction
+        $s = preg_replace('/(\d)\s*([\x{00BD}\x{00BC}\x{00BE}\x{2153}\x{2154}\x{215B}])/u', '$1 $2', $s);
+        // Replace unicode fractions with ASCII equivalents
+        $map = [
+            "\x{00BD}" => '1/2', // ┬¢
+            "\x{00BC}" => '1/4', // ┬╝
+            "\x{00BE}" => '3/4', // ┬¥
+            "\x{2153}" => '1/3', // Ôàô
+            "\x{2154}" => '2/3', // Ôàö
+            "\x{215B}" => '1/8', // Ôàø
+        ];
+        return strtr($s, $map);
+    }
+}
+
+// FIX-QTY-CORE: normalize leading decimals and decimal comma
+if (!function_exists('sitc_normalize_leading_decimal')) {
+    function sitc_normalize_leading_decimal(string $s): string {
+        $s = preg_replace('/(\d),(?=\d)/u', '.', $s);
+        $s = preg_replace('/(?<!\d)\.([0-9]+)/u', '0.$1', $s);
+        return $s;
+    }
+}
+
+// FIX-QTY-CORE: convert ASCII fractions to decimals for tokens
+if (!function_exists('sitc_fraction_to_decimal')) {
+    function sitc_fraction_to_decimal(string $s): string {
+        $s = preg_replace_callback('/(?<!\d)(\d+)\s+(\d+)\/(\d+)(?!\d)/u', function($m){
+            $a=(float)$m[1]; $b=(float)$m[2]; $c=max(1.0,(float)$m[3]); return (string)($a + ($b/$c));
+        }, $s);
+        $s = preg_replace_callback('/(?<!\d)(\d+)\/(\d+)(?!\d)/u', function($m){
+            $b=(float)$m[1]; $c=max(1.0,(float)$m[2]); return (string)($b/$c);
+        }, $s);
+        return $s;
+    }
+}
+
+// FIX-QTY-CORE: Strip leading qty and unit tokens from item string
+if (!function_exists('sitc_strip_leading_qty_unit')) {
+    function sitc_strip_leading_qty_unit(string $s, array $knownUnits): string {
+        $t = trim($s);
+        if ($t === '') return $t;
+        // remove number at start
+        $t = preg_replace('/^\s*(?:\d+(?:[\.,]\d+)?)(?:\s+)?/u', '', $t);
+        // remove optional unit token
+        if ($knownUnits) {
+            $pattern = '/^(?:'.implode('|', array_map(fn($u)=>preg_quote($u,'/'), $knownUnits)).')(?:\.?s)?\b\s*/iu';
+            $t = preg_replace($pattern, '', $t);
+        }
+        return trim($t);
+    }
+}
+// D-FIX: normalize qty tokens (leading dot, decimal comma, unicode fractions to ascii, dashes, "bis")
+if (!function_exists('sitc_normalize_qty_tokens')) {
+    function sitc_normalize_qty_tokens(string $s): string {
+        $t = $s;
+        // NBSP variants to space
+        $t = preg_replace('/[\x{00A0}\x{202F}]/u', ' ', $t);
+        // leading ".50" ├óÔÇáÔÇÖ " 0.50" (space before to aid tokenization), but keep prefix
+        $t = preg_replace('/(^|[^0-9])\.([0-9]+)/u', '$1 0.$2', $t);
+        // decimal comma inside numbers
+        $t = preg_replace('/(\d),(?=\d)/u', '.', $t);
+        // unicode vulgar fraction chars ├óÔÇáÔÇÖ ascii fraction strings
+        $map = [ '├é┬¢'=>'1/2', '├é┬╝'=>'1/4', '├é┬¥'=>'3/4', '├óÔÇªÔÇ£'=>'1/3', '├óÔÇªÔÇØ'=>'2/3', '├óÔÇªÔÇ║'=>'1/8' ];
+        $t = strtr($t, $map);
+        // unify dashes and "bis" to hyphen
+        $t = preg_replace('/[\x{2012}-\x{2015}]/u', '-', $t);
+        $t = preg_replace('/\s+bis\s+/iu', '-', $t);
+        return trim(preg_replace('/\s{2,}/', ' ', $t));
     }
-    return [];
 }
 
-function sitc_normalize_scalar_number($value, $default = 2) {
-    if ($value === '' || $value === null) return $default;
-    $v = is_numeric($value) ? (float)$value : (float)str_replace(',', '.', (string)$value);
-    return $v > 0 ? $v : $default;
+// D-FIX-2: remove consumed prefix from start of line (qty or range fragment)
+if (!function_exists('sitc_trim_consumed_prefix')) {
+    function sitc_trim_consumed_prefix(string $line, string $consumed): string {
+        $l = $line;
+        $c = trim($consumed);
+        if ($c !== '') {
+            $pattern = '/^\s*' . preg_quote($c, '/') . '\s*/u';
+            $l = preg_replace($pattern, '', $l, 1);
+            if ($l === null) $l = $line;
+        }
+        return trim(preg_replace('/\s{2,}/u', ' ', $l));
+    }
 }
 
-function sitc_unit_to_de($unit) {
-    $u = trim(mb_strtolower((string)$unit, 'UTF-8'));
-    if ($u === '') return '';
-    $map = [
-        'tsp' => 'TL', 'teaspoon' => 'TL', 'teaspoons' => 'TL', 'tl' => 'TL',
-        'tbsp' => 'EL', 'tablespoon' => 'EL', 'tablespoons' => 'EL', 'el' => 'EL',
-        'cup' => 'Tasse', 'cups' => 'Tasse', 'tasse' => 'Tasse',
-        'piece' => 'St├â┬╝ck', 'pieces' => 'St├â┬╝ck', 'stueck' => 'St├â┬╝ck', 'st├â┬╝ck' => 'St├â┬╝ck',
-        'pinch' => 'Prise', 'prisen' => 'Prise', 'prise' => 'Prise',
-        'can' => 'Dose', 'dose' => 'Dose',
-        'bunch' => 'Bund', 'bund' => 'Bund',
-        'g' => 'g', 'gram' => 'g', 'grams' => 'g', 'gramm' => 'g',
-        'kg' => 'kg',
-        'ml' => 'ml', 'milliliter' => 'ml', 'millilitre' => 'ml',
-        'l' => 'l', 'liter' => 'l', 'litre' => 'l',
-        'oz' => 'oz', 'ounce' => 'oz', 'ounces' => 'oz',
-        'lb' => 'lb', 'pound' => 'lb', 'pounds' => 'lb',
-    ];
-    $res = $map[$u] ?? $unit;
-    return $res;
+// D-FIX-2: extract unit, item, note from remainder after qty/range
+if (!function_exists('sitc_extract_unit_item_note')) {
+    function sitc_extract_unit_item_note(string $rest): array {
+        $unit = null; $item = ''; $note = null;
+        $s = trim($rest);
+        if ($s === '') return ['unit'=>null,'item'=>'','note'=>null];
+
+        // Leading TK flag becomes part of note
+        if (preg_match('/^TK\b/u', $s)) { $note = 'TK'; $s = trim(preg_replace('/^TK\b\s*/u','', $s)); }
+
+        // Unit at start (letter token)
+        if (preg_match('/^(\p{L}+)/u', $s, $m)) {
+            $uTok = $m[1];
+            $uCanon = sitc_unit_alias_canonical($uTok);
+            if ($uCanon) {
+                $unit = $uCanon;
+                $s = trim(substr($s, strlen($uTok)));
+            } else {
+                $uLower = mb_strtolower($uTok, 'UTF-8');
+                if (in_array($uLower, ['st├╝ck','stÃ¼ck','stueck','stk'], true)) {
+                    $unit = 'piece';
+                    $s = trim(substr($s, strlen($uTok)));
+                }
+            }
+        }
+
+        // Trailing notes: parentheses and comma tail
+        $tn = sitc_extract_trailing_notes($s);
+        $item = trim($tn['clean']);
+        if ($tn['note']) { $note = trim(($note ? $note . '; ' : '') . $tn['note']); }
+
+        // Hyphen note like Ingwer-St├â┬╝ck when weight unit present
+        if ($unit !== null) {
+            $hn = sitc_hyphen_note_split($item, $unit);
+            if ($hn['note']) { $item = $hn['item']; $note = trim(($note ? $note . '; ' : '') . $hn['note']); }
+        }
+
+        $note = $note !== null ? preg_replace('/\s*,\s*/', ', ', trim($note)) : null;
+        return ['unit'=>$unit,'item'=>$item,'note'=>($note!==''?$note:null)];
+    }
 }
 
-function sitc_ucfirst_de(string $s): string {
-    if ($s === '') return $s;
-    $first = mb_substr($s, 0, 1, 'UTF-8');
-    $rest  = mb_substr($s, 1, null, 'UTF-8');
-    if ($first === mb_strtolower($first, 'UTF-8') && $first !== mb_strtoupper($first, 'UTF-8')) {
-        return mb_strtoupper($first, 'UTF-8') . $rest;
+// D-FIX-2: new stable struct builder (no multi-split, range/single-first, robust unit/item/note)
+if (!function_exists('sitc_struct_from_line_df2')) {
+    function sitc_struct_from_line_df2(string $rawLine): array {
+        $out = [];
+        $line = sitc_strip_stopwords_qty_context($rawLine);
+        // FIX-QTY-CORE pre-normalization: unicode fractions, leading decimals, ASCII fractions
+        $line = sitc_normalize_unicode_fractions($line);
+        $line = sitc_normalize_leading_decimal($line);
+        $line = sitc_fraction_to_decimal($line);
+        // Do not destroy slashes; only normalize qty tokens
+        $line = sitc_normalize_qty_tokens($line);
+
+        // Split by bullets/semicolon/2+ spaces
+        $parts = sitc_pcre2_split('/(?:\s*[;ÔÇó┬À]\s+|\h{2,})/u', $line);
+        $parts = array_values(array_filter(array_map('trim', $parts), fn($s)=>$s!=='' && !sitc_is_bare_number($s)));
+        if (!$parts) $parts = [$line];
+
+        foreach ($parts as $part) {
+            $seg = trim($part);
+            if ($seg==='') continue;
+            if (sitc_is_bare_number($seg)) continue;
+
+            $qty = null; $unit = null; $item = ''; $note = null;
+
+            // Range first
+            if (preg_match('/^\s*(\S+\s*\-\s*\S+)\b(.*)$/u', $seg, $m)) {
+                $consumed = trim($m[1]);
+                $r = sitc_extract_range($consumed);
+                    if ($r) {
+                        $qty = $r;
+                        $rest = sitc_trim_consumed_prefix($seg, $consumed);
+                        $e = sitc_extract_unit_item_note($rest);
+                        $unit = $e['unit']; $item = $e['item']; $note = $e['note'];
+                        if (function_exists('sitc_unit_alias_map')) { $item = sitc_strip_leading_qty_unit($item, array_keys(sitc_unit_alias_map())); }
+                    }
+            }
+
+            // Single qty
+            if ($qty === null) {
+                $tokens = sitc_tokenize_numbers_range_aware($seg);
+                if (!empty($tokens)) {
+                    $tok = $tokens[0];
+                    $qv = sitc_parse_mixed_or_fraction($tok);
+                        if ($qv !== null) {
+                            $qty = (float)$qv;
+                            $rest = sitc_trim_consumed_prefix($seg, $tok);
+                            $e = sitc_extract_unit_item_note($rest);
+                            $unit = $e['unit']; $item = $e['item']; $note = $e['note'];
+                            if (function_exists('sitc_unit_alias_map')) { $item = sitc_strip_leading_qty_unit($item, array_keys(sitc_unit_alias_map())); }
+                        }
+                }
+            }
+
+            if ($qty === null && $item === '') { $item = $seg; }
+            $item = trim($item);
+            if ($item === '' && $unit === null) continue;
+            if ($qty !== null && $item === '' && $unit === null) continue;
+            if (sitc_is_bare_number($item)) continue;
+            $out[] = [
+                'raw'  => $seg,
+                'qty'  => $qty,
+                'unit' => $unit,
+                'item' => $item,
+                'note' => $note !== null ? preg_replace('/\s*,\s*/', ', ', trim((string)$note)) : null,
+            ];
+        }
+        return $out;
+    }
+}
+
+// G1 wrappers (compat): qty normalize, range parse, stopwords, notes
+if (!function_exists('sitc_qty_normalize')) {
+    function sitc_qty_normalize(string $s): ?float {
+        if (function_exists('sitc_coerce_qty_float')) {
+            return sitc_coerce_qty_float($s);
+        }
+        $t = trim($s);
+        if ($t === '') return null;
+        if (function_exists('sitc_parse_mixed_or_fraction')) {
+            $v = sitc_parse_mixed_or_fraction($t);
+            return is_float($v) ? $v : null;
+        }
+        $t = str_replace(',', '.', $t);
+        return is_numeric($t) ? (float)$t : null;
+    }
+}
+
+if (!function_exists('sitc_qty_parse_range')) {
+    function sitc_qty_parse_range(string $s): ?array {
+        if (function_exists('sitc_extract_range')) {
+            return sitc_extract_range($s);
+        }
+        $t = preg_replace('/[\x{2012}-\x{2015}]/u', '-', $s) ?? $s;
+        if (preg_match('/^\s*(\S+)\s*-\s*(\S+)/u', trim($t), $m)) {
+            $a = sitc_qty_normalize($m[1]);
+            $b = sitc_qty_normalize($m[2]);
+            if ($a !== null && $b !== null) return ['low'=>(float)$a,'high'=>(float)$b];
+        }
+        return null;
     }
-    return $s;
 }
 
-function sitc_cased_de_ingredient(string $s): string {
-    $t = trim($s);
-    if ($t === '') return $t;
-    $letters = preg_replace('/[^\p{L}\s]/u', '', $t);
-    if ($letters !== '' && $letters === mb_strtolower($letters, 'UTF-8')) {
-        return sitc_ucfirst_de($t);
+if (!function_exists('sitc_strip_stopwords')) {
+    function sitc_strip_stopwords(string $s): string {
+        if (function_exists('sitc_strip_stopwords_qty_context')) {
+            return sitc_strip_stopwords_qty_context($s);
+        }
+        return preg_replace('/^\s*(?:ca\.?|circa|etwa|ungef\.?|about|approx\.?|\(ca\.?\))\s+/iu', ' ', $s) ?? $s;
     }
-    return $t;
 }
 
-function sitc_qty_pre_normalize(string $s): string {
-    $t = trim($s);
-    if ($t === '') return '';
-    $t = preg_replace('/^(ca\.|circa|etwa|ungef\.?|about|approx\.?|approximately)\s+/iu', '', $t);
-    $t = preg_replace('/\s*,\s*/u', ',', $t);
-    $t = preg_replace('/\s*\.\s*/u', '.', $t);
-    return sitc_replace_unicode_fractions($t);
+if (!function_exists('sitc_extract_note_from_item')) {
+    function sitc_extract_note_from_item(string $s): array {
+        if (function_exists('sitc_extract_trailing_notes')) {
+            $tn = sitc_extract_trailing_notes($s);
+            return ['item'=>$tn['clean'], 'note'=>$tn['note']];
+        }
+        $item = trim($s);
+        $note = null;
+        if (preg_match('/^(.*)\(([^\)]*)\)\s*$/u', $item, $m)) { $item = trim($m[1]); $note = trim($m[2]); }
+        if (strpos($item, ',') !== false) {
+            [$l,$r] = array_map('trim', explode(',', $item, 2));
+            $item = $l; $note = ($note ? $note.', ' : '').$r;
+        }
+        $note = $note !== '' ? $note : null;
+        return ['item'=>$item, 'note'=>$note];
+    }
 }
 
-function sitc_replace_unicode_fractions(string $s): string {
-    $map = [
-        '├é┬¢' => '1/2', '├é┬╝' => '1/4', '├é┬¥' => '3/4',
-        '├óÔÇªÔÇ£' => '1/3', '├óÔÇªÔÇØ' => '2/3', '├óÔÇªÔÇ║' => '1/8', '├óÔÇª┼ô' => '3/8', '├óÔÇª┬Ø' => '5/8', '├óÔÇª┼¥' => '7/8',
-    ];
-    return strtr($s, $map);
+// D-FIX: tokenize numbers without splitting ranges (returns array of tokens found in order)
+if (!function_exists('sitc_tokenize_numbers_range_aware')) {
+    function sitc_tokenize_numbers_range_aware(string $s): array {
+        $t = sitc_normalize_qty_tokens($s);
+        $tokens = [];
+        // find candidates: mixed, fraction, decimal, integer
+        $pattern = '/(?:(\d+\s+\d+\/\d+)|(\d+\/\d+)|(\d+\.\d+)|(\d+))/u';
+        if (preg_match_all($pattern, $t, $m, PREG_OFFSET_CAPTURE)) {
+            $matches = [];
+            foreach ($m[0] as $i => $mm) { $matches[] = ['text'=>$mm[0], 'pos'=>$mm[1]]; }
+            // range join: if a '-' appears between consecutive matches with only spaces around
+            for ($i=0; $i < count($matches); $i++) {
+                $cur = $matches[$i];
+                if ($i+1 < count($matches)) {
+                    $next = $matches[$i+1];
+                    $between = substr($t, $cur['pos'] + strlen($cur['text']), $next['pos'] - ($cur['pos'] + strlen($cur['text'])));
+                    if (preg_match('/^\s*\-\s*$/u', $between)) {
+                        $tokens[] = trim($cur['text'] . '-' . $next['text']);
+                        $i++; // skip the next, consumed by range
+                        continue;
+                    }
+                }
+                $tokens[] = $cur['text'];
+            }
+        }
+        return $tokens;
+    }
 }
 
-function sitc_parse_qty_or_range($qty): array {
-    $s = trim((string)$qty);
-    if ($s === '') return ['isRange'=>false,'low'=>null,'high'=>null];
-    $s = sitc_qty_pre_normalize($s);
-    if (preg_match('/^(\d+(?:[\.,]\d+)?)\s*[├óÔé¼ÔÇ£-]\s*(\d+(?:[\.,]\d+)?)$/u', $s, $m)) {
+// D-FIX: parse mixed or fraction to float
+if (!function_exists('sitc_parse_mixed_or_fraction')) {
+    function sitc_parse_mixed_or_fraction(string $num): ?float {
+        $s = trim(sitc_normalize_qty_tokens($num));
+        // mixed a b/c
+        if (preg_match('/^(\d+)\s+(\d+)\/(\d+)$/u', $s, $m)) {
+            $a=(float)$m[1]; $b=(float)$m[2]; $c=max(1.0,(float)$m[3]);
+            return $a + ($b/$c);
+        }
+        // fraction b/c
+        if (preg_match('/^(\d+)\/(\d+)$/u', $s, $m)) {
+            return (float)$m[1]/max(1.0,(float)$m[2]);
+        }
+        // decimal
+        if (preg_match('/^\d+\.\d+$/u', $s)) { return (float)$s; }
+        // integer
+        if (preg_match('/^\d+$/u', $s)) { return (float)$s; }
+        return null;
+    }
+}
+
+// D-FIX: extract range a-b (returns ['low'=>float,'high'=>float] or null). Does not treat slash as range.
+if (!function_exists('sitc_extract_range')) {
+    function sitc_extract_range(string $s): ?array {
+        $t = sitc_normalize_qty_tokens($s);
+        if (preg_match('/^\s*(\S+)\s*\-\s*(\S+)/u', $t, $m)) {
+            $a = sitc_parse_mixed_or_fraction($m[1]);
+            $b = sitc_parse_mixed_or_fraction($m[2]);
+            if ($a !== null && $b !== null) return ['low'=>(float)$a, 'high'=>(float)$b];
+        }
+        return null;
+    }
+}
+
+// E1: New robust ingredient splitter implementing normalization + notes + guards
+if (!function_exists('sitc_struct_from_line_e1')) {
+    function sitc_struct_from_line_e1(string $rawLine): array {
+        $out = [];
+        $pre = sitc_strip_stopwords_qty_context($rawLine);
+        $pre = sitc_unicode_fractions_to_decimal_fixed($pre);
+        $pre = sitc_decimalize_commas_in_numbers($pre);
+        $pn  = sitc_qty_pre_normalize_parser($pre);
+
+        // Split by bullets, middot, semicolon, or 2+ spaces
+        $parts = sitc_pcre2_split('/(?:\s*[;├óÔé¼┬ó├é┬À]\s+|\h{2,})/u', $pn);
+        $parts = array_values(array_filter(array_map('trim', $parts), fn($s)=>$s!=='' && !sitc_is_bare_number($s)));
+        if (!$parts) $parts = [$pn];
+
+        foreach ($parts as $part) {
+            // D-FIX: Do not split when multiple qty tokens appear; keep one segment per part
+            $segments = [$part];
+            foreach ($segments as $seg) {
+                if ($seg==='') continue;
+                if (sitc_is_bare_number($seg)) continue;
+                $qtyField = null; $unitField = null; $itemField = ''; $noteField = null;
+                if (preg_match('/^\s*([^\s,()]+)\s*(\p{L}+)?\s*(.*)$/u', $seg, $m)) {
+                    $qtyParsed = sitc_parse_qty_or_range_parser($m[1]);
+                    if (is_array($qtyParsed) || is_float($qtyParsed)) { $qtyField = $qtyParsed; }
+                    $u = trim((string)($m[2] ?? ''));
+                    $rest = trim((string)($m[3] ?? ''));
+                    if ($u !== '') {
+                        $uLower = mb_strtolower($u, 'UTF-8');
+                        $uCanon = sitc_unit_alias_canonical($u);
+                        if ($uCanon) {
+                            $unitField = $uCanon;
+                        } else {
+                            // Extra: explicit St├â┬╝ck umlaut handling
+                            if ($uLower === 'st├â┬╝ck') { $unitField = 'piece'; }
+                            else {
+                                $rest = trim($u . ' ' . $rest);
+                                if ($uLower === 'tk') { $noteField = trim(($noteField ? $noteField.'; ' : '') . 'TK'); }
+                            }
+                        }
+                    }
+                    if (preg_match('/^TK\b/u', $rest)) { $noteField = 'TK'; $rest = trim(preg_replace('/^TK\b\s*/u','',$rest)); }
+                    $tn = sitc_extract_trailing_notes($rest);
+                    $itemField = $tn['clean'];
+                    if (!empty($tn['note'])) { $noteField = trim(($noteField ? $noteField.', ' : '') . $tn['note']); }
+
+                    if ($unitField===null && preg_match('/^knoblauchzehen?\b/iu', $itemField)) { $unitField='clove'; $itemField='Knoblauch'; }
+                    if ($unitField===null && preg_match('/^(zehe|zehen)\b/iu', $itemField)) { $unitField='clove'; $itemField=preg_replace('/^(zehe|zehen)\b\s*/iu','',$itemField); }
+
+                    if ($unitField !== null) {
+                        $hn = sitc_hyphen_note_split($itemField, $unitField);
+                        if (!empty($hn['note'])) {
+                            $itemField = $hn['item'];
+                            $noteField = trim(($noteField ? $noteField.', ' : '') . $hn['note']);
+                        }
+                    }
+                } else {
+                    $itemField = $seg;
+                }
+                $itemField = trim($itemField);
+                if ($itemField === '' && $unitField === null) continue;
+                if ($qtyField !== null && $itemField === '' && $unitField === null) continue;
+                if (sitc_is_bare_number($itemField)) continue;
+                $out[] = [
+                    'raw'  => $seg,
+                    'qty'  => $qtyField,
+                    'unit' => $unitField,
+                    'item' => $itemField,
+                    'note' => $noteField !== null ? preg_replace('/\s*,\s*/', ', ', trim($noteField)) : null,
+                ];
+            }
+        }
+        return $out;
+    }
+}
+
+// Decimal-comma normalize helper
+if (!function_exists('sitc_num_norm_dec_comma')) {
+    function sitc_num_norm_dec_comma(string $num): string {
+        return str_replace(',', '.', $num);
+    }
+}
+
+// Fixed Unicode fraction map (├é┬╝ ├é┬¢ ├é┬¥ ├óÔÇªÔÇ£ ├óÔÇªÔÇØ ├óÔÇªÔÇ║)
+if (!function_exists('sitc_unicode_fraction_map_fixed')) {
+    function sitc_unicode_fraction_map_fixed(): array {
         return [
-            'isRange' => true,
-            'low'  => (float)str_replace(',', '.', $m[1]),
-            'high' => (float)str_replace(',', '.', $m[2]),
+            '├é┬¢' => 0.5,
+            '├é┬╝' => 0.25,
+            '├é┬¥' => 0.75,
+            '├óÔÇªÔÇ£' => 0.3333,
+            '├óÔÇªÔÇØ' => 0.6667,
+            '├óÔÇªÔÇ║' => 0.125,
         ];
     }
-    if (preg_match('/^(\d+(?:[\.,]\d+)?)$/u', $s, $m)) {
-        return ['isRange'=>false,'low'=>(float)str_replace(',', '.', $m[1]),'high'=>null];
+}
+
+if (!function_exists('sitc_unicode_fractions_to_decimal_fixed')) {
+    function sitc_unicode_fractions_to_decimal_fixed(string $s): string {
+        $map = sitc_unicode_fraction_map_fixed();
+        $class = preg_quote(implode('', array_keys($map)), '/');
+        $s = preg_replace_callback('/(\d)\s*(['.$class.'])/u', function($m) use($map){
+            return (string)((float)$m[1] + (float)$map[$m[2]]);
+        }, $s);
+        $s = preg_replace_callback('/(['.$class.'])/u', function($m) use($map){ return (string)$map[$m[1]]; }, $s);
+        return $s;
     }
-    return ['isRange'=>false,'low'=>null,'high'=>null];
 }
 
-function sitc_format_qty_display($val): string {
-    if ($val === null) return '';
-    $v = (float)$val;
-    if (abs($v - round($v)) < 0.01) $v = round($v);
-    $s = number_format($v, 2, ',', '');
-    return rtrim(rtrim($s, '0'), ',');
+// E1: stopwords around quantity tokens (e.g., ca., circa) removal
+if (!function_exists('sitc_strip_stopwords_qty_context')) {
+    function sitc_strip_stopwords_qty_context(string $s): string {
+        $t = preg_replace('/[\x{00A0}\x{202F}]/u', ' ', $s);
+        if ($t === null) $t = $s;
+        $t = preg_replace('/^\s*(?:ca\.?|circa|etwa|ungef(?:\.|aehr|├â┬ñhr)?|about|approx(?:\.|imately)?|\(ca\.?\))\s+/iu', ' ', $t);
+        if ($t === null) $t = $s;
+        $t = preg_replace('/(?<=\d|\p{L})\s*\((?:ca\.?|circa|about|approx\.?)\)\s*/iu', ' ', $t);
+        if ($t === null) $t = $s;
+        return trim(preg_replace('/\s{2,}/u', ' ', $t));
+    }
 }
 
-function sitc_coerce_qty_float($qty) {
-    $s = trim((string)$qty);
-    if ($s === '') return null;
-    $s = sitc_replace_unicode_fractions($s);
-    if (preg_match('/^(\d+)\s+(\d+)\/(\d+)$/', $s, $m)) { return (float)$m[1] + ((float)$m[2]/max(1,(float)$m[3])); }
-    if (preg_match('/^(\d+)\/(\d+)$/', $s, $m)) { return ((float)$m[1])/max(1,(float)$m[2]); }
-    if (preg_match('/^(\d+(?:[\.,]\d+)?)\s*[├óÔé¼ÔÇ£-]\s*\d+(?:[\.,]\d+)?$/u', $s, $m)) { return (float)str_replace(',', '.', $m[1]); }
-    if (preg_match('/^\d+(?:[\.,]\d+)?$/', $s)) { return (float)str_replace(',', '.', $s); }
-    return null;
+// E1: decimalize commas inside numeric tokens only
+if (!function_exists('sitc_decimalize_commas_in_numbers')) {
+    function sitc_decimalize_commas_in_numbers(string $s): string {
+        return preg_replace('/(\d),(?=\d)/u', '.', $s);
+    }
+}
+
+// E1: convert Unicode fractions and mixed numbers to decimal strings
+if (!function_exists('sitc_unicode_fractions_to_decimal')) {
+    function sitc_unicode_fractions_to_decimal(string $s): string {
+        $map = [ '├é┬¢'=>0.5, '├é┬╝'=>0.25, '├é┬¥'=>0.75, '├óÔÇªÔÇ£'=>0.3333, '├óÔÇªÔÇØ'=>0.6667, '├óÔÇªÔÇ║'=>0.125 ];
+        $class = preg_quote(implode('', array_keys($map)), '/');
+        $s = preg_replace_callback('/(\d)\s*(['.$class.'])/u', function($m) use($map){
+            return (string)((float)$m[1] + (float)$map[$m[2]]);
+        }, $s);
+        $s = preg_replace_callback('/(['.$class.'])/u', function($m) use($map){ return (string)$map[$m[1]]; }, $s);
+        return $s;
+    }
+}
+
+// Map of common Unicode fractions to decimal strings
+if (!function_exists('sitc_unicode_fraction_map')) {
+    function sitc_unicode_fraction_map(): array {
+        return [
+            '├é┬¢' => 0.5,
+            '├é┬╝' => 0.25,
+            '├é┬¥' => 0.75,
+            '├óÔÇªÔÇ£' => 0.3333,
+            '├óÔÇªÔÇØ' => 0.6667,
+            '├óÔÇªÔÇ║' => 0.125,
+        ];
+    }
+}
+
+// Quantity token to float, handling:
+// - Unicode fractions (├é┬¢ ├é┬╝ ├é┬¥ ├óÔÇªÔÇ£ ├óÔÇªÔÇØ ├óÔÇªÔÇ║)
+// - Mixed numbers (1├é┬¢, 1 1/2)
+// - Fractions a/b
+// - Decimal comma
+if (!function_exists('sitc_qty_from_token')) {
+    function sitc_qty_from_token(string $t): ?float {
+        $s = trim($t);
+        if ($s === '') return null;
+        $s = sitc_num_norm_dec_comma($s);
+        $s = preg_replace('/\s*\/\s*/u', '/', $s);
+        if ($s === null) $s = trim($t);
+
+        $map = sitc_unicode_fraction_map_fixed();
+
+        // 1├é┬¢ style
+        if (preg_match('/^([0-9]+)\s*([' . preg_quote(implode('', array_keys($map)), '/') . '])$/u', $s, $m)) {
+            $base = (float)$m[1];
+            $frac = (float)($map[$m[2]] ?? 0.0);
+            return $base + $frac;
+        }
+        // 1 1/2 style
+        if (preg_match('/^([0-9]+)\s+([0-9]+)\/([0-9]+)$/u', $s, $m)) {
+            $a = (float)$m[1];
+            $b = (float)$m[2];
+            $c = max(1.0, (float)$m[3]);
+            return $a + ($b / $c);
+        }
+        // Pure unicode fraction
+        if (preg_match('/^([' . preg_quote(implode('', array_keys($map)), '/') . '])$/u', $s, $m)) {
+            return (float)($map[$m[1]] ?? 0.0);
+        }
+        // Fraction a/b
+        if (preg_match('/^([0-9]+)\/([0-9]+)$/u', $s, $m)) {
+            return (float)$m[1] / max(1.0, (float)$m[2]);
+        }
+        // Decimal
+        if (preg_match('/^[0-9]+(?:\.[0-9]+)?$/u', $s)) {
+            return (float)$s;
+        }
+        return null;
+    }
 }
 
-function sitc_format_qty_de($val) {
-    if ($val === null) return '';
-    $s = number_format((float)$val, 2, ',', '');
-    return rtrim(rtrim($s, '0'), ',');
+// Pre-normalize text around quantities (spaces, dashes, stop-words)
+if (!function_exists('sitc_qty_pre_normalize_parser')) {
+    function sitc_qty_pre_normalize_parser(string $s): string {
+        $t = trim($s);
+        if ($t === '') return '';
+        // NBSP / NNBSP to space
+        $t = preg_replace('/[\x{00A0}\x{202F}]/u', ' ', $t);
+        // drop leading stopwords and (ca.) suffix
+        $t = preg_replace('/^(ca\.?|circa|etwa|ungef\.?|ungef(?:ae|├â┬ñ)hr\.?|about|approx\.?|approximately)\s+/iu', '', $t);
+        $t = preg_replace('/\((?:ca\.?|circa|about|approx\.?)\)\s*$/iu', '', $t);
+        // decimal comma in numbers and leading dot ├óÔÇáÔÇÖ 0.x
+        $t = sitc_decimalize_commas_in_numbers($t);
+        $t = preg_replace('/(^|[^0-9])\.([0-9]+)/u', '$10.$2', $t);
+        // decimal comma in numbers and leading dot ├óÔÇáÔÇÖ 0.x
+        $t = sitc_decimalize_commas_in_numbers($t);
+        $t = preg_replace('/(^|[^0-9])\.([0-9]+)/u', '$10.$2', $t);
+        // unify range separators to hyphen
+        $t = preg_replace('/[\x{2012}-\x{2015}]/u', '-', $t);
+        // tighten slash
+        $t = preg_replace('/\s*\/\s*/u', '/', $t);
+        // Mixed unicode fractions to decimal within text ├ó┼¥┼ô keep comma inside text neutralization for human strings
+        $map = sitc_unicode_fraction_map_fixed();
+        $class = preg_quote(implode('', array_keys($map)), '/');
+        // mixed number: 1├é┬¢ -> 1 + 0.5 (but keep as decimal string; the float parse happens later)
+        $t = preg_replace_callback('/(\d)\s*([' . $class . '])/u', function($m) use ($map){
+            $sum = (float)$m[1] + (float)($map[$m[2]] ?? 0.0);
+            return (string)$sum;
+        }, $t);
+        // standalone unicode fraction -> decimal string
+        $t = preg_replace_callback('/([' . $class . '])/u', function($m) use ($map){
+            return (string)($map[$m[1]] ?? $m[1]);
+        }, $t);
+        // D-FIX: ASCII mixed numbers and fractions to decimal strings
+        $t = preg_replace_callback('/(\d+)\s+(\d+)\/(\d+)/u', function($m){
+            $a=(float)$m[1]; $b=(float)$m[2]; $c=max(1.0,(float)$m[3]);
+            return (string)($a + ($b/$c));
+        }, $t);
+        $t = preg_replace_callback('/\b(\d+)\/(\d+)\b/u', function($m){
+            $b=(float)$m[1]; $c=max(1.0,(float)$m[2]); return (string)($b/$c);
+        }, $t);
+        return $t;
+    }
+}
+
+// Parse quantity or range (a-b)
+if (!function_exists('sitc_parse_qty_or_range_parser')) {
+    function sitc_parse_qty_or_range_parser(string $s) {
+        $t = sitc_normalize_qty_tokens($s);
+        // single value first
+        $v = sitc_parse_mixed_or_fraction($t);
+        if ($v !== null) return (float)$v;
+        // range with hyphen / normalized "bis"
+        $r = sitc_extract_range($t);
+        if ($r !== null) return $r;
+        return null;
+}
+}
+
+// Legacy renderer-facing wrappers to avoid duplicate implementations
+if (!function_exists('sitc_qty_pre_normalize')) {
+    function sitc_qty_pre_normalize(string $s): string { return sitc_qty_pre_normalize_parser($s); }
+}
+
+if (!function_exists('sitc_parse_qty_or_range')) {
+    function sitc_parse_qty_or_range($qty): array {
+        $res = sitc_parse_qty_or_range_parser((string)$qty);
+        if (is_array($res) && isset($res['low'],$res['high'])) return ['isRange'=>true,'low'=>(float)$res['low'],'high'=>(float)$res['high']];
+        if (is_float($res)) return ['isRange'=>false,'low'=>(float)$res,'high'=>null];
+        return ['isRange'=>false,'low'=>null,'high'=>null];
+    }
+}
+
+if (!function_exists('sitc_coerce_qty_float')) {
+    function sitc_coerce_qty_float($qty) {
+        $s = trim((string)$qty);
+        if ($s === '') return null;
+        // Prefer low bound if range
+        $parsed = sitc_parse_qty_or_range_parser($s);
+        if (is_array($parsed) && isset($parsed['low'])) return (float)$parsed['low'];
+        if (is_float($parsed)) return (float)$parsed;
+        return null;
+    }
+}
+
+// Canonical unit aliases (German -> short EN) ├óÔé¼ÔÇ£ parser-internal only
+// E1 helpers: trailing notes, hyphen-notes, bare-number detector
+if (!function_exists('sitc_extract_trailing_notes')) {
+    function sitc_extract_trailing_notes(string $s): array {
+        $item = trim($s);
+        $notes = [];
+        if (preg_match('/^(.*)\(([^\)]*)\)\s*$/u', $item, $m)) {
+            $item = trim($m[1]);
+            $n = trim($m[2]);
+            if ($n !== '') $notes[] = $n;
+        }
+        if (strpos($item, ',') !== false) {
+            $parts = array_map('trim', explode(',', $item, 2));
+            if (count($parts) === 2) {
+                $item = $parts[0];
+                if ($parts[1] !== '') $notes[] = $parts[1];
+            }
+        }
+        $notes = array_values(array_filter(array_unique(array_map(function($n){
+            return preg_replace('/\s{2,}/u',' ', trim($n));
+        }, $notes)), 'strlen'));
+        return ['clean'=>$item, 'note'=>$notes ? implode(', ', $notes) : null];
+    }
+}
+if (!function_exists('sitc_hyphen_note_split')) {
+    function sitc_hyphen_note_split(string $item, ?string $contextUnit): array {
+        $i = trim($item);
+        if ($i === '') return ['item'=>$i, 'note'=>null];
+        $weightUnits = ['g','kg'];
+        if ($contextUnit && in_array($contextUnit, $weightUnits, true)) {
+            $suffixMap = [
+                'st├â┬╝ck'=>'St├â┬╝ck','stk'=>'St├â┬╝ck','stueck'=>'St├â┬╝ck','st├ç┬¼ck'=>'St├â┬╝ck',
+                'scheibe'=>'Scheibe','scheiben'=>'Scheiben',
+                'w├â┬╝rfel'=>'W├â┬╝rfel','wuerfel'=>'W├â┬╝rfel',
+                'streifen'=>'Streifen',
+            ];
+            if (preg_match('/^([\p{L}][\p{L}\-]*)\s*-\s*([\p{L}]+)$/u', $i, $m)) {
+                $right = mb_strtolower($m[2], 'UTF-8');
+                if (isset($suffixMap[$right])) {
+                    return ['item'=>trim($m[1]), 'note'=>$suffixMap[$right]];
+                }
+            }
+        }
+        return ['item'=>$i, 'note'=>null];
+    }
+}
+if (!function_exists('sitc_is_bare_number')) {
+    function sitc_is_bare_number(string $s): bool {
+        $t = trim($s);
+        if ($t === '') return false;
+        return (bool)preg_match('/^\d+(?:[\.,]\d+)?(?:\s*\/\s*\d+)?$/u', $t);
+    }
+}
+if (!function_exists('sitc_unit_alias_canonical')) {
+    function sitc_unit_alias_canonical(string $u): ?string {
+        $m = [
+            'g'=>'g','gram'=>'g','grams'=>'g','gramm'=>'g','gr'=>'g',
+            'kg'=>'kg',
+            'ml'=>'ml','milliliter'=>'ml','millilitre'=>'ml',
+            'l'=>'l','liter'=>'l','litre'=>'l',
+            'tl'=>'tsp','teeloeffel'=>'tsp','teel├â┬Âffel'=>'tsp','tsp'=>'tsp','teaspoon'=>'tsp','teaspoons'=>'tsp',
+            'el'=>'tbsp','essloeffel'=>'tbsp','essl├â┬Âffel'=>'tbsp','tbsp'=>'tbsp','tablespoon'=>'tbsp','tablespoons'=>'tbsp',
+            'tasse'=>'cup','tassen'=>'cup','cup'=>'cup','cups'=>'cup',
+            'prise'=>'pinch','prisen'=>'pinch','pinch'=>'pinch',
+            'stk'=>'piece','st├â┬╝ck'=>'piece','stueck'=>'piece','piece'=>'piece','pieces'=>'piece',
+            'dose'=>'can','dosen'=>'can','can'=>'can',
+            'bund'=>'bunch','b├â┬╝ndel'=>'bunch','bunch'=>'bunch',
+            'zehe'=>'clove','zehen'=>'clove','clove'=>'clove','cloves'=>'clove',
+        ];
+        $k = mb_strtolower(trim($u), 'UTF-8');
+        return $m[$k] ?? null;
+    }
+}
+
+// Structured ingredient splitter from a single line ├óÔÇáÔÇÖ one or more entries
+// Returns list of: { raw, qty:?float|{low,high}, unit:?string, item:string, note:?string }
+if (!function_exists('sitc_struct_from_line')) {
+    function sitc_struct_from_line(string $rawLine): array {
+        $out = [];
+        $pn = sitc_qty_pre_normalize_parser($rawLine);
+
+        // Split by common delimiters: bullets, middot, semicolon, or 2+ horizontal spaces
+        $parts = sitc_pcre2_split('/(?:\s*[;├óÔé¼┬ó├é┬À]\s+|\h{2,})/u', $pn);
+        $parts = array_values(array_filter(array_map('trim', $parts), fn($s)=>$s!==''));
+        if (!$parts) $parts = [$pn];
+
+        foreach ($parts as $part) {
+            // If a part contains multiple qty tokens, split conservatively at subsequent tokens
+            if (preg_match_all('/(?:(?:\d+(?:[\.,]\d+)?)|\d+\/\d+)/u', $part, $mm, PREG_OFFSET_CAPTURE) && count($mm[0])>1) {
+                $segments = [];
+                $last = 0;
+                foreach ($mm[0] as $i=>$m) {
+                    if ($i===0) continue;
+                    $off = $m[1];
+                    $segments[] = trim(substr($part, $last, $off-$last));
+                    $last = $off;
+                }
+                $segments[] = trim(substr($part, $last));
+            } else {
+                $segments = [$part];
+            }
+
+            foreach ($segments as $seg) {
+                if ($seg==='') continue;
+                $qtyField = null; $unitField = null; $itemField = ''; $noteField = null;
+                // qty + optional unit at start
+                if (preg_match('/^\s*([^\s,()]+)\s*(\p{L}+)?\s*(.*)$/u', $seg, $m)) {
+                    $qtyParsed = sitc_parse_qty_or_range_parser($m[1]);
+                    if (is_array($qtyParsed) || is_float($qtyParsed)) { $qtyField = $qtyParsed; }
+                    $u = trim((string)($m[2] ?? ''));
+                    $rest = trim((string)($m[3] ?? ''));
+                    if ($u !== '') {
+                        $uLower = mb_strtolower($u, 'UTF-8');
+                        $uCanon = sitc_unit_alias_canonical($u);
+                        if ($uCanon) {
+                            $unitField = $uCanon;
+                        } else {
+                            // Unknown letter token following qty: treat as part of item (e.g., "Nelken")
+                            $rest = trim($u . ' ' . $rest);
+                            // Special-case: TK as note
+                            if ($uLower === 'tk') {
+                                $noteField = trim(($noteField ? $noteField.'; ' : '') . 'TK');
+                            }
+                        }
+                    }
+                    // Leading TK flag as note
+                    if (preg_match('/^TK\b/u', $rest)) { $noteField = 'TK'; $rest = trim(preg_replace('/^TK\b\s*/u','',$rest)); }
+                    // Parentheses note
+                    if (preg_match('/^(.*)\(([^\)]+)\)\s*$/u', $rest, $n)) { $itemField = trim($n[1]); $noteField = trim(($noteField? $noteField.'; ':'').$n[2]); }
+                    else $itemField = $rest;
+                    // Trailing comma note
+                    if (strpos($itemField, ',') !== false) {
+                        $parts2 = array_map('trim', explode(',', $itemField, 2));
+                        if (count($parts2)===2) { $itemField = $parts2[0]; $noteField = trim(($noteField? $noteField.'; ':'').$parts2[1]); }
+                    }
+                    // Heuristics: Knoblauchzehen ├óÔÇáÔÇÖ unit clove + item Knoblauch
+                    if ($unitField===null && preg_match('/^knoblauchzehen?\b/iu', $itemField)) { $unitField='clove'; $itemField='Knoblauch'; }
+                    if ($unitField===null && preg_match('/^(zehe|zehen)\b/iu', $itemField)) { $unitField='clove'; $itemField=preg_replace('/^(zehe|zehen)\b\s*/iu','',$itemField); }
+                } else {
+                    $itemField = $seg;
+                }
+                $out[] = [
+                    'raw'  => $seg,
+                    'qty'  => $qtyField,
+                    'unit' => $unitField,
+                    'item' => trim($itemField),
+                    'note' => $noteField !== null ? $noteField : null,
+                ];
+            }
+        }
+        return $out;
+    }
 }
=== ingredients (new files) ===
.\includes\ingredients\note.php SHA256: A89EA360B6BA74B7771FC8DD9C1C8C3607FA06B08B64370F01CC4F5692C006A4 (no archive)
.\includes\ingredients\parse_line.php SHA256: DB995FB61B2476D381708597C5260864FEC072A5C027814977B5CE68A8CC51F0 (no archive)
.\includes\ingredients\qty.php SHA256: 61AD624FC1A6246A46B6232CB7C7214D9FE4DF541F637009CF050EFC418086E9 (no archive)
.\includes\ingredients\tokenize.php SHA256: C8BD8A8114827C9E2BD01E13ECF442E573EFF44570A556276556312E45D5BB82 (no archive)
.\includes\ingredients\unit.php SHA256: 15C64405F2976C6EAE8FEA5AB4CDE548906B2D8421F1FDA31F99D5C5D057C8A9 (no archive)
=== tools/parser_lab/lib/harness.php ===
Current tools/parser_lab/lib/harness.php SHA256: 0B1017A0798152A3223C1D01D35E9831CFC50A61824860AC4DF3015AA8FEC8F2
