<?php
if (!defined('ABSPATH')) exit;

/**
 * Hilfsfunktionen
 */
function sitc_normalize_array_meta($value) {
    if (is_array($value)) return $value;
    if (is_string($value) && $value !== '') {
        $json = json_decode($value, true);
        if (json_last_error() === JSON_ERROR_NONE && is_array($json)) return $json;
        $maybe = maybe_unserialize($value);
        if (is_array($maybe)) return $maybe;
    }
    return [];
}
function sitc_normalize_scalar_number($value, $default = 2) {
    if ($value === '' || $value === null) return $default;
    $v = is_numeric($value) ? (float)$value : (float)str_replace(',', '.', (string)$value);
    return $v > 0 ? $v : $default;
}

// Einheitenausgabe (DE) â€“ nur Anzeige-Mapping
// Siehe DEV_NOTES.md: â€žEinheiten-Policy (DE)â€œ
function sitc_unit_to_de($unit) {
    $u = trim(mb_strtolower((string)$unit, 'UTF-8'));
    if ($u === '') return '';
    $map = [
        'tsp' => 'TL', 'teaspoon' => 'TL', 'teaspoons' => 'TL', 'tl' => 'TL',
        'tbsp' => 'EL', 'tablespoon' => 'EL', 'tablespoons' => 'EL', 'el' => 'EL',
        'cup' => 'Tasse', 'cups' => 'Tasse', 'tasse' => 'Tasse',
        'piece' => 'StÃ¼ck', 'pieces' => 'StÃ¼ck', 'stÃ¼ck' => 'StÃ¼ck', 'stueck' => 'StÃ¼ck',
        'pinch' => 'Prise', 'prisen' => 'Prise', 'prise' => 'Prise',
        'can' => 'Dose', 'dose' => 'Dose',
        'bunch' => 'Bund', 'bund' => 'Bund',
        'g' => 'g', 'gram' => 'g', 'grams' => 'g', 'gramm' => 'g',
        'kg' => 'kg',
        'ml' => 'ml', 'milliliter' => 'ml', 'millilitre' => 'ml',
        'l' => 'l', 'liter' => 'l', 'litre' => 'l',
        'oz' => 'oz', 'ounce' => 'oz', 'ounces' => 'oz',
        'lb' => 'lb', 'pound' => 'lb', 'pounds' => 'lb',
    ];
    return $map[$u] ?? $unit;
}

// Helper: Uppercase first letter (DE safe)
function sitc_ucfirst_de(string $s): string {
    if ($s === '') return $s;
    // If first char is a letter and lowercase, uppercase it
    $first = mb_substr($s, 0, 1, 'UTF-8');
    $rest  = mb_substr($s, 1, null, 'UTF-8');
    if ($first === mb_strtolower($first, 'UTF-8') && $first !== mb_strtoupper($first, 'UTF-8')) {
        return mb_strtoupper($first, 'UTF-8') . $rest;
    }
    return $s;
}

// Helper: Heuristic display casing for German ingredient lines
// Goal: Preserve source casing where present; if everything is lowercase,
// capitalize likely nouns while keeping common adjectives/conjunctions lowercase.
function sitc_cased_de_ingredient(string $s): string {
    if ($s === '') return $s;
    // Do not early-return on internal uppercase: we still want to
    // capitalize the first lowercase ingredient word like "zitrone (Saft ...)"

    $lowerKeep = [
        // conjunctions / prepositions / articles common in ingredients
        'und','oder','mit','ohne','in','im','am','vom','von','zum','zur','zu','auf','an','aus','fÃ¼r','fuer','bei','als','der','die','das','den','dem','des','ein','eine','einer','einem','eines'
    ];
    $adjBase = [
        // common adjectives/descriptors in ingredient lines (base lemmas)
        'gemahlen','gehackt','gerieben','gepresst','gequetscht','geschÃ¤lt','geschaelt','getrocknet','frisch','weich','hart','grob','fein','klein','groÃŸ','gross','mittelgroÃŸ','mittelgross','kalt','warm','heiÃŸ','heiss','lauwarm','zart','reif','ungesalzen','gesalzen','gewÃ¼rfelt','gewuerfelt','in','halbiert','geviertelt','entkernt','ohne','mit'
    ];
    $isAdj = function(string $w) use ($adjBase): bool {
        $l = mb_strtolower($w, 'UTF-8');
        // strip common adjective inflections
        foreach (['e','en','em','er','es','n','s'] as $suf) {
            if (mb_strlen($l,'UTF-8') > mb_strlen($suf,'UTF-8') && mb_substr($l, -mb_strlen($suf,'UTF-8'), null, 'UTF-8') === $suf) {
                $stem = mb_substr($l, 0, -mb_strlen($suf,'UTF-8'), 'UTF-8');
                if (in_array($stem, $adjBase, true)) return true;
            }
        }
        return in_array($l, $adjBase, true);
    };

    $tokens = preg_split('/(\s+)/u', $s, -1, PREG_SPLIT_DELIM_CAPTURE);
    $out = [];
    foreach ($tokens as $tok) {
        // preserve whitespace as-is
        if (preg_match('/^\s+$/u', $tok)) { $out[] = $tok; continue; }
        // hyphenated parts treated separately
        $parts = preg_split('/(-)/u', $tok, -1, PREG_SPLIT_DELIM_CAPTURE);
        $newTok = '';
        foreach ($parts as $p) {
            if ($p === '-') { $newTok .= $p; continue; }
            $lc = mb_strtolower($p, 'UTF-8');
            // keep known lowercase words and adjectives lowercase (preserve punctuation)
            if (in_array($lc, $lowerKeep, true) || $isAdj($p)) { $newTok .= $lc; continue; }

            // If token contains any letters, and all its letters are lowercase,
            // uppercase the first letter character (but keep parentheses/digits intact).
            if ($p !== '' && preg_match('/\p{L}/u', $p)) {
                $lettersOnly = preg_replace('/[^\p{L}]+/u', '', $p);
                if ($lettersOnly !== '' && $lettersOnly === mb_strtolower($lettersOnly, 'UTF-8')) {
                    $done = false;
                    $len = mb_strlen($p, 'UTF-8');
                    for ($i=0; $i<$len; $i++) {
                        $ch = mb_substr($p, $i, 1, 'UTF-8');
                        if (!$done && preg_match('/\p{Ll}/u', $ch)) {
                            $newTok .= mb_strtoupper($ch, 'UTF-8');
                            $done = true;
                        } else {
                            $newTok .= $ch;
                        }
                    }
                    continue;
                }
            }

            // otherwise preserve as-is
            $newTok .= $p;
        }
        $out[] = $newTok;
    }
    return implode('', $out);
}

// Detect if a line looks like a section header according to heuristics
function sitc_is_group_header(string $line): bool {
    $t = trim($line);
    if ($t === '') return false;
    // Ends with colon
    if (preg_match('/:\s*$/u', $t)) return true;
    // All-caps (letters) with spaces/hyphens allowed
    $letters = preg_replace('/[^\p{L}]+/u', '', $t);
    if ($letters !== '' && mb_strtoupper($letters, 'UTF-8') === $letters && mb_strlen($letters, 'UTF-8') >= 3) {
        return true;
    }
    // Keyword heuristics (DE/EN), case-insensitive
    $keywords = [
        'ENTE','BEILAGE','SAUCE','GARNITUR','TOPPING','FÃœR DIE BIRRIA','FUER DIE BIRRIA','FÃœR DIE TACOS','FUER DIE TACOS',
        'MARINADE','DRESSING','SPICE MIX','FÃœLLUNG','FUELLUNG','TEIG'
    ];
    $u = mb_strtoupper($t, 'UTF-8');
    foreach ($keywords as $kw) {
        if (mb_strpos($u, $kw, 0, 'UTF-8') !== false) return true;
    }
    return false;
}

// Build ingredient groups from schema or from recipeIngredient heuristics
function sitc_build_ingredient_groups_for_render(int $post_id): array {
    $raw = get_post_meta($post_id, '_sitc_schema_recipe_json', true);
    $schema = null;
    if (is_string($raw) && $raw !== '') {
        $decoded = json_decode($raw, true);
        if (is_array($decoded)) $schema = $decoded;
    }

    $groups = [];
    // 1) Use schema.ingredientGroups if present
    if (is_array($schema) && !empty($schema['ingredientGroups']) && is_array($schema['ingredientGroups'])) {
        foreach ($schema['ingredientGroups'] as $g) {
            $name = isset($g['name']) ? trim((string)$g['name']) : '';
            $items = [];
            if (!empty($g['items']) && is_array($g['items'])) {
                foreach ($g['items'] as $it) {
                    $s = trim((string)$it);
                    if ($s !== '') $items[] = $s;
                }
            }
            if ($items) $groups[] = ['name' => $name !== '' ? $name : ' ', 'items' => $items];
        }
        if ($groups) return $groups;
    }

    // 2) Heuristic: derive from schema.recipeIngredient if present
    $lines = [];
    if (is_array($schema) && !empty($schema['recipeIngredient'])) {
        $src = $schema['recipeIngredient'];
        if (!is_array($src)) $src = [$src];
        foreach ($src as $s) {
            $t = trim((string)$s);
            if ($t !== '') $lines[] = $t;
        }
    }
    if (!$lines) return [];

    $curName = null; $curItems = []; $out = []; $foundHeader = false;
    foreach ($lines as $line) {
        $t = trim($line);
        if ($t === '') continue;
        // Guard: lines that look like real ingredients (qty/unit) should not be treated as headers
        $looksLikeIngredient = (
            preg_match('/^\s*(?:\d|\p{N}|[Â¼Â½Â¾â…“â…”â…›â…œâ…â…ž])/u', $t) ||
            preg_match('/\b(g|kg|ml|l|tl|el|tsp|tbsp|cup|prise|pinch|dose|bund|oz|lb|can|bunch)\b/i', $t)
        );
        if (!$looksLikeIngredient && sitc_is_group_header($t)) {
            // flush previous
            if ($curName !== null) {
                if ($curItems) $out[] = ['name'=>$curName,'items'=>$curItems];
                $curItems = [];
            }
            $foundHeader = true;
            $name = rtrim($t, ": ");
            $curName = $name !== '' ? $name : ' ';
        } else {
            if ($curName === null) {
                // before first header: collect but we will only use if no header was found at all
                $curItems[] = $t;
            } else {
                $curItems[] = $t;
            }
        }
    }
    if ($curName !== null && $curItems) $out[] = ['name'=>$curName,'items'=>$curItems];
    // If no header detected at all, return empty to signal fallback to ungrouped rendering
    if (!$foundHeader) return [];
    // Filter out empty groups
    $groups = array_values(array_filter($out, function($g){ return !empty($g['items']); }));
    return $groups;
}

// From grouped raw lines, run global de-dupe and return structured items per group
function sitc_prepare_grouped_items(array $groups): array {
    // Build first-occurrence map for dedupe keys -> group index
    $firstGroup = [];
    $allLines = [];
    foreach ($groups as $gi => $g) {
        foreach ($g['items'] as $line) {
            $raw = sitc_clean_text((string)$line);
            if ($raw === '') continue;
            // compute key like sitc_dedupe_ingredients
            if (function_exists('sitc_parse_ingredient_line_v3')) {
                $p = sitc_parse_ingredient_line_v3($raw);
            } else {
                $p = sitc_parse_ingredient_line_v2($raw);
            }
            $qtyKey = sitc_parse_qty_key($p['qty'] ?? null);
            $unitKey = sitc_unit_canonical($p['unit'] ?? null) ?? '';
            if ($unitKey === 'piece') { $unitKey = ''; }
            $itemKey = sitc_ing_item_key((string)($p['item'] ?? ''));
            $key = md5($itemKey.'|'.$unitKey.'|'.$qtyKey);
            if (!isset($firstGroup[$key])) $firstGroup[$key] = $gi;
            $allLines[] = $raw;
        }
    }

    // Run generic dedupe to merge notes consistently
    [$dispLines, $parsed] = sitc_dedupe_ingredients($allLines);

    // Bucket parsed items to their first group, preserving order returned by dedupe
    $grouped = [];
    foreach ($groups as $gi => $g) {
        $grouped[$gi] = [ 'name' => $g['name'], 'items' => [] ];
    }

    foreach ($parsed as $p) {
        $qtyKey = sitc_parse_qty_key($p['qty'] ?? null);
        $unitKey = sitc_unit_canonical($p['unit'] ?? null) ?? '';
        if ($unitKey === 'piece') { $unitKey = ''; }
        $itemKey = sitc_ing_item_key((string)($p['item'] ?? ''));
        $key = md5($itemKey.'|'.$unitKey.'|'.$qtyKey);
        $gi = isset($firstGroup[$key]) ? (int)$firstGroup[$key] : 0;

        // Map parsed -> renderer struct {qty, unit, name}
        $name = trim((string)($p['item'] ?? ''));
        $note = trim((string)($p['note'] ?? ''));
        if ($note !== '') $name .= ' (' . $note . ')';
        $qty = isset($p['qty']) ? (string)$p['qty'] : '';
        $unit = isset($p['unit']) ? (string)$p['unit'] : '';

        $grouped[$gi]['items'][] = [ 'qty' => $qty, 'unit' => $unit, 'name' => $name ];
    }

    // Drop empty groups (e.g., all items deduped into earlier groups)
    $out = [];
    foreach ($grouped as $gi => $g) {
        if (!empty($g['items'])) $out[] = $g;
    }
    return $out;
}

// Helper: Unicode-BrÃ¼che â†’ ASCII (Vor-Normalisierung fÃ¼r Mengen)
function sitc_replace_unicode_fractions(string $s): string {
    $map = [
        'Â½' => '1/2', 'Â¼' => '1/4', 'Â¾' => '3/4',
        'â…“' => '1/3', 'â…”' => '2/3',
        'â…›' => '1/8', 'â…œ' => '3/8', 'â…' => '5/8', 'â…ž' => '7/8',
    ];
    return strtr($s, $map);
}

// Mengen-Parsing: Einzelwert oder Bereich (a-b)
function sitc_parse_qty_or_range($qty): array {
    $res = ['low'=>null, 'high'=>null, 'isRange'=>false];
    if ($qty === null) return $res;
    $s = trim((string)$qty);
    if ($s === '') return $res;
    $s = sitc_replace_unicode_fractions($s);
    $s = preg_replace('/\s*\/\s*/', '/', $s); // Spaces um "/" entfernen
    $s = str_replace(['â€“','â€”',' to '], ['-','-','-'], $s); // Bereichsseparatoren

    $toFloat = function(string $t){
        $t = trim($t);
        $t = sitc_replace_unicode_fractions($t);
        $t = preg_replace('/\s*\/\s*/', '/', $t);
        if (preg_match('/^(\d+)\s+(\d+)\/(\d+)$/', $t, $m)) {
            return (float)$m[1] + ((float)$m[2]/max(1,(float)$m[3]));
        }
        if (preg_match('/^(\d+)\/(\d+)$/', $t, $m)) {
            return ((float)$m[1])/max(1,(float)$m[2]);
        }
        if (preg_match('/^\d+(?:[\.,]\d+)?$/', $t)) {
            return (float)str_replace(',', '.', $t);
        }
        return null;
    };

    if (preg_match('/^(.+?)\s*-\s*(.+)$/', $s, $rm)) {
        $a = $toFloat($rm[1]); $b = $toFloat($rm[2]);
        if ($a !== null && $b !== null) { $res['low']=$a; $res['high']=$b; $res['isRange']=true; return $res; }
    }
    $v = $toFloat($s);
    if ($v !== null) { $res['low'] = $v; }
    return $res;
}

// Anzeige-Format (DE) mit Ganzzahl-Schwelle
function sitc_format_qty_display($val): string {
    if ($val === null) return '';
    $v = (float)$val;
    if (abs($v - round($v)) < 0.01) $v = round($v);
    $s = number_format($v, 2, ',', '');
    return rtrim(rtrim($s, '0'), ',');
}

// Mengen-Parsing: 1/2, 1 1/2, Â½, 1,5 => float
function sitc_coerce_qty_float($qty) {
    if ($qty === null) return null;
    $s = trim((string)$qty);
    if ($s === '') return null;
    $s = strtr($s, ['Â½'=>'1/2','Â¼'=>'1/4','Â¾'=>'3/4','â…“'=>'1/3','â…”'=>'2/3','â…›'=>'1/8','â…œ'=>'3/8','â…'=>'5/8','â…ž'=>'7/8']);
    if (preg_match('/^(\d+)\s+(\d+)\/(\d+)$/', $s, $m)) { return (float)$m[1] + ((float)$m[2]/max(1,(float)$m[3])); }
    if (preg_match('/^(\d+)\/(\d+)$/', $s, $m)) { return ((float)$m[1])/max(1,(float)$m[2]); }
    if (preg_match('/^(\d+(?:[\.,]\d+)?)\s*[-â€“]\s*\d+(?:[\.,]\d+)?$/u', $s, $m)) { return (float)str_replace(',', '.', $m[1]); }
    if (preg_match('/^\d+(?:[\.,]\d+)?$/', $s)) { return (float)str_replace(',', '.', $s); }
    return null;
}

function sitc_format_qty_de($val) {
    if ($val === null) return '';
    $s = number_format((float)$val, 2, ',', '');
    return rtrim(rtrim($s, '0'), ',');
}

/**
 * Renderer
 */
function sitc_render_recipe_shortcode($post_id = 0) {
    $post_id = $post_id ? (int)$post_id : get_the_ID();
    if (!$post_id) return '';

    $ingredients  = sitc_normalize_array_meta(get_post_meta($post_id, '_sitc_ingredients_struct', true));
    $instructions = sitc_normalize_array_meta(get_post_meta($post_id, '_sitc_instructions', true));

    $yield_num = get_post_meta($post_id, '_sitc_yield_num', true);
    if ($yield_num === '' || $yield_num === null) {
        $maybe_raw = get_post_meta($post_id, '_sitc_yield', true);
        if (is_numeric($maybe_raw)) $yield_num = $maybe_raw;
    }
    $yield_num = sitc_normalize_scalar_number($yield_num, 2);

    $yield_raw = get_post_meta($post_id, '_sitc_yield_raw', true);
    if ($yield_raw === '' || $yield_raw === null) {
        $legacy = get_post_meta($post_id, '_sitc_yield', true);
        if (!empty($legacy)) $yield_raw = $legacy;
    }

    $source_url = get_post_meta($post_id, '_sitc_source_url', true);

    $trash_token = get_post_meta($post_id, '_sitc_trash_token', true);
    if (!$trash_token) {
        $trash_token = wp_generate_password(20, false, false);
        update_post_meta($post_id, '_sitc_trash_token', $trash_token);
    }

    $show_original = false;
    if (!empty($yield_raw)) {
        if (preg_match('/(\d+(?:[.,]\d+)?)/u', $yield_raw, $m)) {
            $raw_num = (float)str_replace(',', '.', $m[1]);
            if ((float)$yield_num != $raw_num) $show_original = true;
        } else {
            $show_original = true;
        }
    }

    if (empty($ingredients) && empty($instructions)) return '';

    wp_enqueue_style('sitc-recipe');
    wp_enqueue_script('sitc-recipe');

    ob_start(); ?>
    <div class="sitc-recipe" data-post="<?php echo (int)$post_id; ?>">
        <div class="sitc-controls">
            <span class="sitc-yield-label">Personenanzahl:</span>
            <div class="sitc-servings-control">
                <button type="button" class="sitc-btn sitc-btn-minus">âˆ’</button>
                <span class="sitc-servings-display" data-base-servings="<?php echo esc_attr($yield_num); ?>">
                    <?php echo esc_html($yield_num); ?>
                </span>
                <button type="button" class="sitc-btn sitc-btn-plus">+</button>
            </div>
            <?php if ($show_original): ?>
                <span class="sitc-yield-raw">(Original: <?php echo esc_html($yield_raw); ?>)</span>
            <?php endif; ?>
            <input type="number" class="sitc-servings" value="<?php echo esc_attr($yield_num); ?>" min="1" step="1" style="display:none;">

            <div class="sitc-actions">
                <button type="button" class="sitc-btn sitc-btn-grocery" data-target="#sitc-list-<?php echo $post_id; ?>" aria-expanded="false" title="Einkaufsliste"><span class="material-symbols-outlined">shopping_cart</span></button>
                <button type="button" class="sitc-btn sitc-btn-wake" title="Bildschirm anlassen"><span class="material-symbols-outlined">toggle_on</span></button>
                <button type="button" class="sitc-btn sitc-btn-trash" data-post="<?php echo $post_id; ?>" data-token="<?php echo esc_attr($trash_token); ?>" title="Rezept lÃ¶schen"><span class="material-symbols-outlined">delete</span></button>
                <button type="button" class="sitc-btn sitc-btn-photo" title="Foto hinzufÃ¼gen"><span class="material-symbols-outlined">add_a_photo</span></button>
            </div>
        </div>
        <?php
            // Group-aware rendering: prefer ingredientGroups if present, else heuristic from recipeIngredient
            $sourceGroups = sitc_build_ingredient_groups_for_render($post_id);
            $groupsForRender = [];
            if (!empty($sourceGroups)) {
                $groupsForRender = sitc_prepare_grouped_items($sourceGroups);
            }
        ?>
        <?php if (!empty($groupsForRender)) : ?>
            <h3>Zutaten</h3>
            <?php foreach ($groupsForRender as $group): ?>
                <h4 class="sitc-ingredient-group"><?php echo esc_html(trim((string)$group['name'])); ?></h4>
                <ul class="sitc-ingredients" data-base-servings="<?php echo esc_attr($yield_num); ?>">
                <?php foreach ($group['items'] as $ing):
                    $qtyRaw  = $ing['qty'] ?? '';
                    $unitRaw = $ing['unit'] ?? '';
                    $name    = $ing['name'] ?? '';
                    $nameDisp = sitc_cased_de_ingredient(trim((string)$name));
                    $qInfo   = sitc_parse_qty_or_range($qtyRaw);
                    if ($qInfo['isRange']) {
                        $dispQty = sitc_format_qty_display($qInfo['low']) . 'â€“' . sitc_format_qty_display($qInfo['high']);
                    } elseif ($qInfo['low'] !== null) {
                        $dispQty = sitc_format_qty_display($qInfo['low']);
                    } else {
                        $dispQty = trim((string)$qtyRaw);
                    }
                    $unitDe  = sitc_unit_to_de($unitRaw);

                    $id_for = 'sitc_chk_' . $post_id . '_' . md5($qtyRaw.'|'.$unitRaw.'|'.$name);
                    ?>
                    <li class="sitc-ingredient"
                        <?php if ($qInfo['isRange']): ?>
                            data-qty-low="<?php echo esc_attr(str_replace(',','.', (string)$qInfo['low'])); ?>"
                            data-qty-high="<?php echo esc_attr(str_replace(',','.', (string)$qInfo['high'])); ?>"
                        <?php else: ?>
                            data-qty="<?php echo esc_attr($qInfo['low'] !== null ? str_replace(',','.', (string)$qInfo['low']) : ''); ?>"
                        <?php endif; ?>
                        data-unit="<?php echo esc_attr($unitDe); ?>" data-name="<?php echo esc_attr($name); ?>">
                        <label for="<?php echo esc_attr($id_for); ?>">
                            <input type="checkbox" id="<?php echo esc_attr($id_for); ?>" class="sitc-chk">
                            <span class="sitc-line">
                                <span class="sitc-qty"><?php echo esc_html($dispQty); ?></span>
                                <?php if ($unitDe !== ''): ?><span class="sitc-unit"> <?php echo esc_html($unitDe); ?></span><?php endif; ?>
                                <span class="sitc-name"> <?php echo esc_html($nameDisp); ?></span>
                            </span>
                        </label>
                    </li>
                <?php endforeach; ?>
                </ul>
            <?php endforeach; ?>

            <div id="sitc-list-<?php echo $post_id; ?>" class="sitc-grocery collapsed" hidden>
                <h4>Einkaufsliste</h4>
                <ul>
                    <?php foreach ($groupsForRender as $group): foreach ($group['items'] as $ing):
                        $qtyRaw  = $ing['qty'] ?? '';
                        $unitRaw = $ing['unit'] ?? '';
                        $name    = $ing['name'] ?? '';
                        $nameDisp = sitc_cased_de_ingredient(trim((string)$name));
                        $qInfo   = sitc_parse_qty_or_range($qtyRaw);
                        if ($qInfo['isRange']) {
                            $dispQty = sitc_format_qty_display($qInfo['low']) . 'â€“' . sitc_format_qty_display($qInfo['high']);
                        } elseif ($qInfo['low'] !== null) {
                            $dispQty = sitc_format_qty_display($qInfo['low']);
                        } else {
                            $dispQty = trim((string)$qtyRaw);
                        }
                        $unitDe  = sitc_unit_to_de($unitRaw);
                        ?>
                        <li><?php echo esc_html(trim(($dispQty !== '' ? $dispQty.' ' : '').($unitDe ? $unitDe.' ' : '').$nameDisp)); ?></li>
                    <?php endforeach; endforeach; ?>
                </ul>
            </div>

        <?php elseif (!empty($ingredients)) : ?>
            <h3>Zutaten</h3>
            <ul class="sitc-ingredients" data-base-servings="<?php echo esc_attr($yield_num); ?>">
                <?php foreach ($ingredients as $ing):
                    $qtyRaw  = $ing['qty'] ?? '';
                    $unitRaw = $ing['unit'] ?? '';
                    $name    = $ing['name'] ?? '';
                    $nameDisp = sitc_cased_de_ingredient(trim((string)$name));
                    $qInfo   = sitc_parse_qty_or_range($qtyRaw);
                    if ($qInfo['isRange']) {
                        $dispQty = sitc_format_qty_display($qInfo['low']) . 'â€“' . sitc_format_qty_display($qInfo['high']);
                    } elseif ($qInfo['low'] !== null) {
                        $dispQty = sitc_format_qty_display($qInfo['low']);
                    } else {
                        $dispQty = trim((string)$qtyRaw);
                    }
                    $unitDe  = sitc_unit_to_de($unitRaw);

                    $id_for = 'sitc_chk_' . $post_id . '_' . md5($qtyRaw.'|'.$unitRaw.'|'.$name);
                    ?>
                    <li class="sitc-ingredient"
                        <?php if ($qInfo['isRange']): ?>
                            data-qty-low="<?php echo esc_attr(str_replace(',','.', (string)$qInfo['low'])); ?>"
                            data-qty-high="<?php echo esc_attr(str_replace(',','.', (string)$qInfo['high'])); ?>"
                        <?php else: ?>
                            data-qty="<?php echo esc_attr($qInfo['low'] !== null ? str_replace(',','.', (string)$qInfo['low']) : ''); ?>"
                        <?php endif; ?>
                        data-unit="<?php echo esc_attr($unitDe); ?>" data-name="<?php echo esc_attr($name); ?>">
                        <label for="<?php echo esc_attr($id_for); ?>">
                            <input type="checkbox" id="<?php echo esc_attr($id_for); ?>" class="sitc-chk">
                            <span class="sitc-line">
                                <span class="sitc-qty"><?php echo esc_html($dispQty); ?></span>
                                <?php if ($unitDe !== ''): ?><span class="sitc-unit"> <?php echo esc_html($unitDe); ?></span><?php endif; ?>
                                <span class="sitc-name"> <?php echo esc_html($nameDisp); ?></span>
                            </span>
                        </label>
                    </li>
                <?php endforeach; ?>
            </ul>

            <div id="sitc-list-<?php echo $post_id; ?>" class="sitc-grocery collapsed" hidden>
                <h4>Einkaufsliste</h4>
                <ul>
                    <?php foreach ($ingredients as $ing):
                        $qtyRaw  = $ing['qty'] ?? '';
                        $unitRaw = $ing['unit'] ?? '';
                        $name    = $ing['name'] ?? '';
                        $nameDisp = sitc_cased_de_ingredient(trim((string)$name));
                        $qInfo   = sitc_parse_qty_or_range($qtyRaw);
                        if ($qInfo['isRange']) {
                            $dispQty = sitc_format_qty_display($qInfo['low']) . 'â€“' . sitc_format_qty_display($qInfo['high']);
                        } elseif ($qInfo['low'] !== null) {
                            $dispQty = sitc_format_qty_display($qInfo['low']);
                        } else {
                            $dispQty = trim((string)$qtyRaw);
                        }
                        $unitDe  = sitc_unit_to_de($unitRaw);
                        ?>
                        <li><?php echo esc_html(trim(($dispQty !== '' ? $dispQty.' ' : '').($unitDe ? $unitDe.' ' : '').$nameDisp)); ?></li>
                    <?php endforeach; ?>
                </ul>
            </div>
        <?php endif; ?>

        <?php if (!empty($instructions)) : ?>
            <h3>Zubereitung</h3>
            <ol class="sitc-instructions">
                <?php foreach ($instructions as $step):
                    $step = trim((string)$step);
                    if ($step === '') continue;
                    $step = preg_replace('/^\s*\d+[\)\.\:\-]\s+/u', '', $step);
                    ?>
                    <li><?php echo esc_html($step); ?></li>
                <?php endforeach; ?>
            </ol>
        <?php endif; ?>

        <?php if (!empty($source_url)) : ?>
            <p class="sitc-source">
                Quelle: <a href="<?php echo esc_url($source_url); ?>" target="_blank" rel="nofollow noopener">Originalrezept ansehen</a>
            </p>
        <?php endif; ?>
    </div>
    <?php
    return ob_get_clean();
}

/**
 * Auto-Anhang
 */
add_filter('the_content', function($content){
    if (!is_singular('post')) return $content;

    $post_id = get_the_ID();
    if (!$post_id) return $content;

    if (strpos($content, 'class="sitc-recipe"') !== false) return $content;

    $has_ingredients  = get_post_meta($post_id, '_sitc_ingredients_struct', true);
    $has_instructions = get_post_meta($post_id, '_sitc_instructions', true);
    if (!$has_ingredients && !$has_instructions) return $content;

    $block = sitc_render_recipe_shortcode($post_id);
    if ($block === '') return $content;

    return $content . "\n\n" . $block;
}, 9999);
